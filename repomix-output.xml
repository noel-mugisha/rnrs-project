This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/.env.example
backend/.gitignore
backend/.wiki.md
backend/eslint.config.js
backend/jest.config.js
backend/nodemon.json
backend/package.json
backend/postman_collection.json
backend/prisma/schema.prisma
backend/src/app.ts
backend/src/config/cloudinary.ts
backend/src/config/database.ts
backend/src/config/email.ts
backend/src/config/logger.ts
backend/src/config/redis.ts
backend/src/controllers/applicationController.ts
backend/src/controllers/authController.ts
backend/src/controllers/employerController.ts
backend/src/controllers/jobController.ts
backend/src/controllers/notificationController.ts
backend/src/controllers/resumeController.ts
backend/src/controllers/userController.ts
backend/src/middleware/authMiddleware.ts
backend/src/middleware/errorHandlerMiddleware.ts
backend/src/middleware/rateLimiterMiddleware.ts
backend/src/middleware/validationMiddleware.ts
backend/src/routes/applicationRoutes.ts
backend/src/routes/authRoutes.ts
backend/src/routes/employerRoutes.ts
backend/src/routes/index.ts
backend/src/routes/jobRoutes.ts
backend/src/routes/notificationRoutes.ts
backend/src/routes/resumeRoutes.ts
backend/src/routes/userRoutes.ts
backend/src/scripts/seed.ts
backend/src/server.ts
backend/src/services/applicationService.ts
backend/src/services/authService.ts
backend/src/services/employerService.ts
backend/src/services/jobService.ts
backend/src/services/notificationService.ts
backend/src/services/resumeService.ts
backend/src/services/userService.ts
backend/src/types/index.ts
backend/src/utils/auth.ts
backend/src/utils/response.ts
backend/src/utils/slugify.ts
backend/src/utils/validation.ts
backend/tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/.env.example">
# Server Configuration
NODE_ENV=your-environment
PORT=your-port-number

# Database
DATABASE_URL=postgresql://username:password@localhost:5432/your-database-name

# Redis
REDIS_URL=redis://localhost:6379

# JWT Secrets
JWT_SECRET=your-jwt-secret-key
REFRESH_TOKEN_SECRET=your-refresh-token-secret-key
JWT_EXPIRES_IN=jwt-expires-in-min
REFRESH_TOKEN_EXPIRES_IN=refresh-token-expires-in-days

# Cloudinary Configuration
CLOUDINARY_CLOUD_NAME=your-cloudinary-cloud-name
CLOUDINARY_API_KEY=your-cloudinary-api-key
CLOUDINARY_API_SECRET=your-cloudinary-api-secret

# Email Configuration (Nodemailer)
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_SECURE=false
EMAIL_USER=your-email@gmail.com
EMAIL_PASS=your-app-password
EMAIL_FROM=noreply@your-email.com

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# File Upload Limits
MAX_FILE_SIZE=10485760
ALLOWED_FILE_TYPES=application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document

# Frontend URL (for CORS and email links)
FRONTEND_URL=http://localhost:3000

# Security
BCRYPT_ROUNDS=12
OTP_EXPIRES_IN=600000

# Socket.IO
SOCKET_IO_CORS_ORIGIN=http://localhost:3000
</file>

<file path="backend/.gitignore">
# Change later
README.md

# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test
.env.production
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
public

# Storybook build outputs
.out
.storybook-out

# Temporary folders
tmp/
temp/

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage

# nyc test coverage
.nyc_output

# Grunt intermediate storage (http://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# next.js build output
.next

# Build output
dist/
build/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Prisma
prisma/migrations/
</file>

<file path="backend/.wiki.md">
# Project Summary
The Job Portal Backend API is designed to facilitate job searching and recruitment processes. This comprehensive backend system allows job seekers to manage their profiles, apply for jobs, and track their applications, while job providers can post job openings, manage applications, and communicate with candidates. Built using Express.js, TypeScript, and Prisma with PostgreSQL, this API integrates essential features such as user authentication, resume management, and notifications, creating a seamless experience for both job seekers and employers.

# Project Module Description
- **Authentication & Authorization**: Handles user registration, login, and email verification with JWT and OTP.
- **User Management**: Manages user profiles, including job seekers and employers.
- **Job Management**: Allows job providers to create, manage, and publish job listings.
- **Application Management**: Enables job seekers to apply for jobs and track their application status.
- **Resume Management**: Facilitates uploading and managing resumes using Cloudinary.
- **Notification System**: Sends notifications to users regarding application statuses and other updates.

# Directory Tree
```
src/
├── config/          # Configuration files (database, redis, cloudinary, etc.)
├── controllers/     # Request handlers
├── middleware/      # Express middleware (auth, validation, rate limiting)
├── routes/          # API route definitions
├── services/        # Business logic layer
├── types/           # TypeScript type definitions
├── utils/           # Utility functions
├── scripts/         # Database seeds and utility scripts
├── app.ts           # Express app configuration
└── server.ts        # Server startup
```

# File Description Inventory
- **config/**: Contains configuration files for database, logging, email, and external services.
- **controllers/**: Implements the logic for handling requests and responses.
- **middleware/**: Includes middleware for authentication, validation, and error handling.
- **routes/**: Defines the API endpoints and their corresponding controllers.
- **services/**: Contains business logic and interactions with the database.
- **types/**: TypeScript type definitions for better type safety.
- **utils/**: Utility functions for various common tasks.
- **scripts/**: Scripts for database seeding and other utility functions.
- **app.ts**: Main Express application setup.
- **server.ts**: Entry point for starting the server.

# Technology Stack
- **Runtime**: Node.js 18+
- **Framework**: Express.js with TypeScript
- **Database**: PostgreSQL with Prisma ORM
- **Cache/Queue**: Redis with BullMQ
- **File Storage**: Cloudinary
- **Email**: Nodemailer
- **Authentication**: JWT with refresh tokens
- **Validation**: Zod
- **Testing**: Jest
- **Logging**: Winston

# Usage
### 1. Clone and Install Dependencies
```bash
git clone <repository-url>
cd job-portal-backend
npm install
```

### 2. Environment Setup
Copy the `.env.example` file to `.env` and configure your environment variables:
```bash
cp .env.example .env
```

### 3. Database Setup
```bash
npm run db:generate      # Generate Prisma client
npm run db:migrate       # Run database migrations
npm run db:seed          # Seed the database with sample data
```

### 4. Start the Server
```bash
npm run dev              # Development mode with hot reload
npm run build            # Build for production
npm start                # Start production server
```

### 5. Testing
Import `postman_collection.json` into Postman for API testing.
</file>

<file path="backend/eslint.config.js">
module.exports = {
  parser: '@typescript-eslint/parser',
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
  ],
  plugins: ['@typescript-eslint'],
  parserOptions: {
    ecmaVersion: 2020,
    sourceType: 'module',
  },
  env: {
    node: true,
    es6: true,
  },
  rules: {
    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-non-null-assertion': 'warn',
    'no-console': 'warn',
    'prefer-const': 'error',
    'no-var': 'error',
  },
  ignorePatterns: ['dist/', 'node_modules/', '*.js'],
};
</file>

<file path="backend/jest.config.js">
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  roots: ['<rootDir>/src'],
  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],
  transform: {
    '^.+\\.ts$': 'ts-jest',
  },
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/**/*.d.ts',
    '!src/server.ts',
    '!src/scripts/**',
  ],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  moduleNameMapping: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
};
</file>

<file path="backend/nodemon.json">
{
  "watch": ["src"],
  "ext": "ts",
  "ignore": ["src/**/*.test.ts"],
  "exec": "ts-node -r tsconfig-paths/register src/server.ts"
}
</file>

<file path="backend/postman_collection.json">
{
  "info": {
    "name": "Job Portal API",
    "description": "Complete API collection for Job Portal Backend",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    "version": "1.0.0"
  },
  "auth": {
    "type": "bearer",
    "bearer": [
      {
        "key": "token",
        "value": "{{accessToken}}",
        "type": "string"
      }
    ]
  },
  "variable": [
    {
      "key": "baseUrl",
      "value": "http://localhost:4000/api/v1",
      "type": "string"
    },
    {
      "key": "accessToken",
      "value": "",
      "type": "string"
    },
    {
      "key": "userId",
      "value": "",
      "type": "string"
    },
    {
      "key": "employerId",
      "value": "",
      "type": "string"
    },
    {
      "key": "jobId",
      "value": "",
      "type": "string"
    },
    {
      "key": "applicationId",
      "value": "",
      "type": "string"
    },
    {
      "key": "resumeId",
      "value": "",
      "type": "string"
    }
  ],
  "item": [
    {
      "name": "Health Check",
      "request": {
        "method": "GET",
        "header": [],
        "url": {
          "raw": "{{baseUrl}}/health",
          "host": ["{{baseUrl}}"],
          "path": ["health"]
        }
      }
    },
    {
      "name": "Authentication",
      "item": [
        {
          "name": "Signup Job Seeker",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "if (pm.response.code === 201) {",
                  "    const response = pm.response.json();",
                  "    pm.collectionVariables.set('userId', response.data.userId);",
                  "}"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"firstName\": \"John\",\n  \"lastName\": \"Doe\",\n  \"email\": \"john.doe@example.com\",\n  \"password\": \"Password123!\",\n  \"role\": \"JOBSEEKER\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/auth/signup",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "signup"]
            }
          }
        },
        {
          "name": "Signup Job Provider",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"firstName\": \"Jane\",\n  \"lastName\": \"Smith\",\n  \"email\": \"jane.smith@company.com\",\n  \"password\": \"Password123!\",\n  \"role\": \"JOBPROVIDER\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/auth/signup",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "signup"]
            }
          }
        },
        {
          "name": "Verify Email OTP",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "if (pm.response.code === 200) {",
                  "    const response = pm.response.json();",
                  "    pm.collectionVariables.set('accessToken', response.data.accessToken);",
                  "}"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"userId\": \"{{userId}}\",\n  \"otp\": \"123456\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/auth/verify-email-otp",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "verify-email-otp"]
            }
          }
        },
        {
          "name": "Resend Email OTP",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"userId\": \"{{userId}}\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/auth/resend-email-otp",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "resend-email-otp"]
            }
          }
        },
        {
          "name": "Login",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "if (pm.response.code === 200) {",
                  "    const response = pm.response.json();",
                  "    pm.collectionVariables.set('accessToken', response.data.accessToken);",
                  "}"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"email\": \"jobseeker@example.com\",\n  \"password\": \"JobSeeker123!\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/auth/login",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "login"]
            }
          }
        },
        {
          "name": "Refresh Token",
          "request": {
            "method": "POST",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/auth/refresh",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "refresh"]
            }
          }
        },
        {
          "name": "Logout",
          "request": {
            "method": "POST",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/auth/logout",
              "host": ["{{baseUrl}}"],
              "path": ["auth", "logout"]
            }
          }
        }
      ]
    },
    {
      "name": "User Profile",
      "item": [
        {
          "name": "Get Current User",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/users/me",
              "host": ["{{baseUrl}}"],
              "path": ["users", "me"]
            }
          }
        },
        {
          "name": "Update Profile",
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"phone\": \"+1234567890\",\n  \"desiredTitle\": \"Senior Software Engineer\",\n  \"about\": \"Experienced full-stack developer with expertise in React and Node.js\",\n  \"skills\": [\n    {\n      \"id\": \"1\",\n      \"name\": \"JavaScript\",\n      \"confidence\": 5\n    },\n    {\n      \"id\": \"2\",\n      \"name\": \"React\",\n      \"confidence\": 5\n    },\n    {\n      \"id\": \"3\",\n      \"name\": \"Node.js\",\n      \"confidence\": 4\n    }\n  ],\n  \"privacy\": {\n    \"hideContact\": false\n  }\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/users/me",
              "host": ["{{baseUrl}}"],
              "path": ["users", "me"]
            }
          }
        }
      ]
    },
    {
      "name": "Resume Management",
      "item": [
        {
          "name": "Request Upload URL",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "if (pm.response.code === 200) {",
                  "    const response = pm.response.json();",
                  "    pm.collectionVariables.set('resumeId', response.data.resumeId);",
                  "}"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"fileName\": \"john_doe_resume.pdf\",\n  \"fileType\": \"application/pdf\",\n  \"fileSize\": 1048576\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/resumes/request-upload",
              "host": ["{{baseUrl}}"],
              "path": ["resumes", "request-upload"]
            }
          }
        },
        {
          "name": "Complete Upload",
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"resumeId\": \"{{resumeId}}\",\n  \"storageKey\": \"job-portal/resumes/resume-id\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/resumes/complete-upload",
              "host": ["{{baseUrl}}"],
              "path": ["resumes", "complete-upload"]
            }
          }
        },
        {
          "name": "Get My Resumes",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/resumes",
              "host": ["{{baseUrl}}"],
              "path": ["resumes"]
            }
          }
        },
        {
          "name": "Get Resume by ID",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/resumes/{{resumeId}}",
              "host": ["{{baseUrl}}"],
              "path": ["resumes", "{{resumeId}}"]
            }
          }
        },
        {
          "name": "Delete Resume",
          "request": {
            "method": "DELETE",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/resumes/{{resumeId}}",
              "host": ["{{baseUrl}}"],
              "path": ["resumes", "{{resumeId}}"]
            }
          }
        }
      ]
    },
    {
      "name": "Employer Management",
      "item": [
        {
          "name": "Create Employer",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "if (pm.response.code === 201) {",
                  "    const response = pm.response.json();",
                  "    pm.collectionVariables.set('employerId', response.data.id);",
                  "}"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"name\": \"TechCorp Inc.\",\n  \"website\": \"https://techcorp.com\",\n  \"industry\": \"Technology\",\n  \"location\": \"San Francisco, CA\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/employers",
              "host": ["{{baseUrl}}"],
              "path": ["employers"]
            }
          }
        },
        {
          "name": "Get My Employer",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/employers/me",
              "host": ["{{baseUrl}}"],
              "path": ["employers", "me"]
            }
          }
        },
        {
          "name": "Get Employer by ID",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/employers/{{employerId}}",
              "host": ["{{baseUrl}}"],
              "path": ["employers", "{{employerId}}"]
            }
          }
        },
        {
          "name": "Update Employer",
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"name\": \"TechCorp Solutions Inc.\",\n  \"website\": \"https://techcorpsolutions.com\",\n  \"industry\": \"Software Development\",\n  \"location\": \"San Francisco, CA\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/employers/{{employerId}}",
              "host": ["{{baseUrl}}"],
              "path": ["employers", "{{employerId}}"]
            }
          }
        }
      ]
    },
    {
      "name": "Job Management",
      "item": [
        {
          "name": "Create Job",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "if (pm.response.code === 201) {",
                  "    const response = pm.response.json();",
                  "    pm.collectionVariables.set('jobId', response.data.id);",
                  "}"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"title\": \"Senior Full Stack Developer\",\n  \"description\": \"We are looking for an experienced full stack developer to join our growing team. You will be responsible for developing and maintaining web applications using modern technologies.\",\n  \"responsibilities\": [\n    \"Develop and maintain web applications\",\n    \"Collaborate with cross-functional teams\",\n    \"Write clean, maintainable code\",\n    \"Mentor junior developers\"\n  ],\n  \"requirements\": [\n    \"5+ years of experience in full stack development\",\n    \"Proficiency in JavaScript, React, and Node.js\",\n    \"Experience with databases (PostgreSQL, MongoDB)\",\n    \"Strong problem-solving skills\"\n  ],\n  \"location\": \"San Francisco, CA\",\n  \"remote\": true,\n  \"jobType\": \"FULL_TIME\",\n  \"experienceLevel\": \"SENIOR\",\n  \"salaryRange\": {\n    \"min\": 120000,\n    \"max\": 180000,\n    \"currency\": \"USD\"\n  }\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/employers/{{employerId}}/jobs",
              "host": ["{{baseUrl}}"],
              "path": ["employers", "{{employerId}}", "jobs"]
            }
          }
        },
        {
          "name": "Get Employer Jobs",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/employers/{{employerId}}/jobs?page=1&limit=10",
              "host": ["{{baseUrl}}"],
              "path": ["employers", "{{employerId}}", "jobs"],
              "query": [
                {
                  "key": "page",
                  "value": "1"
                },
                {
                  "key": "limit",
                  "value": "10"
                }
              ]
            }
          }
        },
        {
          "name": "Search Jobs (Public)",
          "request": {
            "auth": {
              "type": "noauth"
            },
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/jobs/search?q=developer&location=San Francisco&remote=true&page=1&limit=10",
              "host": ["{{baseUrl}}"],
              "path": ["jobs", "search"],
              "query": [
                {
                  "key": "q",
                  "value": "developer"
                },
                {
                  "key": "location",
                  "value": "San Francisco"
                },
                {
                  "key": "remote",
                  "value": "true"
                },
                {
                  "key": "page",
                  "value": "1"
                },
                {
                  "key": "limit",
                  "value": "10"
                }
              ]
            }
          }
        },
        {
          "name": "Get Job by ID (Public)",
          "request": {
            "auth": {
              "type": "noauth"
            },
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/jobs/{{jobId}}",
              "host": ["{{baseUrl}}"],
              "path": ["jobs", "{{jobId}}"]
            }
          }
        },
        {
          "name": "Update Job",
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"title\": \"Senior Full Stack Developer (Updated)\",\n  \"description\": \"Updated job description with more details about the role and company culture.\",\n  \"remote\": true,\n  \"salaryRange\": {\n    \"min\": 130000,\n    \"max\": 190000,\n    \"currency\": \"USD\"\n  }\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/jobs/{{jobId}}",
              "host": ["{{baseUrl}}"],
              "path": ["jobs", "{{jobId}}"]
            }
          }
        },
        {
          "name": "Publish Job",
          "request": {
            "method": "POST",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/jobs/{{jobId}}/publish",
              "host": ["{{baseUrl}}"],
              "path": ["jobs", "{{jobId}}", "publish"]
            }
          }
        },
        {
          "name": "Get Job Applicants",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/jobs/{{jobId}}/applicants?page=1&limit=10",
              "host": ["{{baseUrl}}"],
              "path": ["jobs", "{{jobId}}", "applicants"],
              "query": [
                {
                  "key": "page",
                  "value": "1"
                },
                {
                  "key": "limit",
                  "value": "10"
                }
              ]
            }
          }
        }
      ]
    },
    {
      "name": "Applications",
      "item": [
        {
          "name": "Apply to Job",
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "if (pm.response.code === 201) {",
                  "    const response = pm.response.json();",
                  "    pm.collectionVariables.set('applicationId', response.data.applicationId);",
                  "}"
                ]
              }
            }
          ],
          "request": {
            "method": "POST",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              },
              {
                "key": "Idempotency-Key",
                "value": "{{$guid}}"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"resumeId\": \"{{resumeId}}\",\n  \"coverLetter\": \"I am very interested in this position and believe my skills and experience make me a great fit for your team.\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/applications/jobs/{{jobId}}/apply",
              "host": ["{{baseUrl}}"],
              "path": ["applications", "jobs", "{{jobId}}", "apply"]
            }
          }
        },
        {
          "name": "Get My Applications",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/applications?page=1&limit=10",
              "host": ["{{baseUrl}}"],
              "path": ["applications"],
              "query": [
                {
                  "key": "page",
                  "value": "1"
                },
                {
                  "key": "limit",
                  "value": "10"
                }
              ]
            }
          }
        },
        {
          "name": "Get Application by ID",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/applications/{{applicationId}}",
              "host": ["{{baseUrl}}"],
              "path": ["applications", "{{applicationId}}"]
            }
          }
        },
        {
          "name": "Update Application Status",
          "request": {
            "method": "PATCH",
            "header": [
              {
                "key": "Content-Type",
                "value": "application/json"
              }
            ],
            "body": {
              "mode": "raw",
              "raw": "{\n  \"status\": \"VIEWED\",\n  \"note\": \"Application reviewed by hiring manager\"\n}"
            },
            "url": {
              "raw": "{{baseUrl}}/applications/{{applicationId}}/status",
              "host": ["{{baseUrl}}"],
              "path": ["applications", "{{applicationId}}", "status"]
            }
          }
        }
      ]
    },
    {
      "name": "Notifications",
      "item": [
        {
          "name": "Get Notifications",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/notifications?page=1&limit=20",
              "host": ["{{baseUrl}}"],
              "path": ["notifications"],
              "query": [
                {
                  "key": "page",
                  "value": "1"
                },
                {
                  "key": "limit",
                  "value": "20"
                }
              ]
            }
          }
        },
        {
          "name": "Get Unread Notifications",
          "request": {
            "method": "GET",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/notifications?read=false&page=1&limit=20",
              "host": ["{{baseUrl}}"],
              "path": ["notifications"],
              "query": [
                {
                  "key": "read",
                  "value": "false"
                },
                {
                  "key": "page",
                  "value": "1"
                },
                {
                  "key": "limit",
                  "value": "20"
                }
              ]
            }
          }
        },
        {
          "name": "Mark Notification as Read",
          "request": {
            "method": "PATCH",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/notifications/notification-id/read",
              "host": ["{{baseUrl}}"],
              "path": ["notifications", "notification-id", "read"]
            }
          }
        },
        {
          "name": "Mark All Notifications as Read",
          "request": {
            "method": "PATCH",
            "header": [],
            "url": {
              "raw": "{{baseUrl}}/notifications/mark-all-read",
              "host": ["{{baseUrl}}"],
              "path": ["notifications", "mark-all-read"]
            }
          }
        }
      ]
    }
  ]
}
</file>

<file path="backend/prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String   @id @default(uuid())
  firstName          String
  lastName           String
  email              String   @unique
  passwordHash       String
  role               Role
  emailVerified      Boolean  @default(false)
  phone              String?  
  phoneVerified      Boolean  @default(false)
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  
  jobSeekerProfile   JobSeekerProfile?
  employerProfile    Employer?
  refreshTokens      RefreshToken[]
  notifications      Notification[]
  consents           Consent[]
  employerAdmins     EmployerAdmin[]
  emailVerifications EmailVerification[]
  
  @@map("users")
}

model EmailVerification {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  otp   String
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  @@map("email_verifications")
}

model RefreshToken {
  id         String   @id @default(uuid())
  tokenHash  String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  revoked    Boolean  @default(false)
  createdAt  DateTime @default(now())
  expiresAt  DateTime
  
  @@map("refresh_tokens")
}

enum Role {
  JOBSEEKER
  JOBPROVIDER
  ADMIN
}

model JobSeekerProfile {
  id            String    @id @default(uuid())
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String    @unique
  desiredTitle  String?
  about         String?
  skills        Json?
  privacy       Json?
  resumes       Resume[]
  applications  Application[]
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@map("job_seeker_profiles")
}

model Resume {
  id          String   @id @default(uuid())
  jobSeeker   JobSeekerProfile @relation(fields: [jobSeekerId], references: [id], onDelete: Cascade)
  jobSeekerId String
  fileKey     String
  fileName    String
  mimeType    String
  size        Int
  fingerprint String   @unique
  parsedJson  Json?
  parseStatus ParseStatus @default(PENDING)
  createdAt   DateTime @default(now())
  parsedAt    DateTime?
  deleted     Boolean  @default(false)
  applications Application[]
  
  @@map("resumes")
}

enum ParseStatus {
  PENDING
  PROCESSING
  SUCCESS
  FAILED
}

model Employer {
  id           String   @id @default(uuid())
  owner        User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId      String   @unique
  name         String
  website      String?
  industry     String?
  location     String?
  logoKey      String?
  jobs         Job[]
  admins       EmployerAdmin[]
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@map("employers")
}

model EmployerAdmin {
  id         String   @id @default(uuid())
  employer   Employer @relation(fields: [employerId], references: [id], onDelete: Cascade)
  employerId String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  role       String
  createdAt  DateTime @default(now())
  
  @@unique([employerId, userId])
  @@map("employer_admins")
}

model Job {
  id             String    @id @default(uuid())
  employer       Employer  @relation(fields: [employerId], references: [id], onDelete: Cascade)
  employerId     String
  title          String
  slug           String    @unique
  description    String
  responsibilities String[]
  requirements   String[]
  location       String?
  remote         Boolean   @default(false)
  jobType        String
  experienceLevel String
  salaryRange    Json?
  status         JobStatus @default(DRAFT)
  applications   Application[]
  postedAt       DateTime?
  expiresAt      DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  
  @@index([status, postedAt])
  @@index([employerId])
  @@map("jobs")
}

enum JobStatus {
  DRAFT
  PUBLISHED
  CLOSED
  ARCHIVED
}

model Application {
  id             String    @id @default(uuid())
  job            Job       @relation(fields: [jobId], references: [id], onDelete: Cascade)
  jobId          String
  jobSeeker      JobSeekerProfile @relation(fields: [jobSeekerId], references: [id], onDelete: Cascade)
  jobSeekerId    String
  resume         Resume?   @relation(fields: [resumeId], references: [id])
  resumeId       String?
  coverLetter    String?
  status         ApplicationStatus @default(APPLIED)
  statusHistory  Json?
  metadata       Json?
  appliedAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  
  @@unique([jobId, jobSeekerId])
  @@index([jobId, status])
  @@index([jobSeekerId])
  @@map("applications")
}

enum ApplicationStatus {
  APPLIED
  VIEWED
  SHORTLISTED
  INTERVIEW_SCHEDULED
  OFFERED
  HIRED
  REJECTED
}

model Notification {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  type      String
  payload   Json
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  
  @@index([userId, read])
  @@map("notifications")
}

model Consent {
  id        String   @id @default(uuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  type      String
  details   Json?
  acceptedAt DateTime @default(now())
  
  @@map("consents")
}
</file>

<file path="backend/src/config/cloudinary.ts">
import { v2 as cloudinary } from 'cloudinary';
import { logger } from './logger';

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

export const uploadToCloudinary = async (
  buffer: Buffer,
  options: {
    folder?: string;
    resource_type?: 'image' | 'video' | 'raw' | 'auto';
    public_id?: string;
    format?: string;
  } = {}
): Promise<any> => {
  return new Promise((resolve, reject) => {
    const uploadOptions = {
      resource_type: 'auto' as const,
      folder: 'job-portal',
      ...options,
    };

    cloudinary.uploader.upload_stream(
      uploadOptions,
      (error, result) => {
        if (error) {
          logger.error('Cloudinary upload error:', error);
          reject(error);
        } else {
          resolve(result);
        }
      }
    ).end(buffer);
  });
};

export const deleteFromCloudinary = async (publicId: string): Promise<any> => {
  try {
    const result = await cloudinary.uploader.destroy(publicId);
    logger.info(`Deleted file from Cloudinary: ${publicId}`);
    return result;
  } catch (error) {
    logger.error('Cloudinary delete error:', error);
    throw error;
  }
};

export const generateUploadSignature = (params: Record<string, any>): string => {
  return cloudinary.utils.api_sign_request(params, process.env.CLOUDINARY_API_SECRET!);
};

export { cloudinary };
</file>

<file path="backend/src/config/database.ts">
import { PrismaClient } from '@prisma/client';
import { logger } from './logger';

const prisma = new PrismaClient({
  log: [
    {
      emit: 'event',
      level: 'query',
    },
    {
      emit: 'event',
      level: 'error',
    },
    {
      emit: 'event',
      level: 'info',
    },
    {
      emit: 'event',
      level: 'warn',
    },
  ],
});

prisma.$on('error', (e) => {
  logger.error('Prisma error:', e);
});

prisma.$on('warn', (e) => {
  logger.warn('Prisma warning:', e);
});

prisma.$on('info', (e) => {
  logger.info('Prisma info:', e);
});

if (process.env.NODE_ENV === 'development') {
  prisma.$on('query', (e) => {
    logger.debug(`Query: ${e.query}`);
    logger.debug(`Params: ${e.params}`);
    logger.debug(`Duration: ${e.duration}ms`);
  });
}

export { prisma };
</file>

<file path="backend/src/config/email.ts">
import nodemailer from 'nodemailer';
import { logger } from './logger';

const transporter = nodemailer.createTransport({
  host: process.env.EMAIL_HOST,
  port: parseInt(process.env.EMAIL_PORT || '587'),
  secure: process.env.EMAIL_SECURE === 'true',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

transporter.verify((error, success) => {
  if (error) {
    logger.error('Email transporter verification failed:', error);
  } else {
    logger.info('Email transporter is ready');
  }
});

export const sendEmail = async (options: {
  to: string | string[];
  subject: string;
  html: string;
  text?: string;
}): Promise<void> => {
  try {
    const mailOptions = {
      from: process.env.EMAIL_FROM,
      ...options,
    };

    const info = await transporter.sendMail(mailOptions);
    logger.info(`Email sent: ${info.messageId}`);
  } catch (error) {
    logger.error('Failed to send email:', error);
    throw error;
  }
};

export { transporter };
</file>

<file path="backend/src/config/redis.ts">
import Redis from 'ioredis';
import { logger } from './logger';

const redis = new Redis(process.env.REDIS_URL || 'redis://localhost:6379', {
  lazyConnect: true,
  connectTimeout: 10000,
  commandTimeout: 5000,
  enableReadyCheck: true,
  maxRetriesPerRequest: 3,
  retryStrategy: (times: number) => {
    const delay = Math.min(times * 50, 2000);
    logger.info(`Redis retry attempt ${times}, waiting ${delay}ms`);
    return delay;
  },
});

redis.on('connect', () => {
  logger.info('Connecting to Redis...');
});

redis.on('ready', () => {
  logger.info('Redis connection established and ready');
});

redis.on('error', (error) => {
  logger.error('Redis connection error:', error);
});

redis.on('close', () => {
  logger.warn('Redis connection closed');
});

redis.on('reconnecting', () => {
  logger.info('Attempting to reconnect to Redis...');
});

redis.on('end', () => {
  logger.warn('Redis connection ended');
});

// Test connection on startup
redis.ping().then(() => {
  logger.info('Redis ping successful');
}).catch((error) => {
  logger.error('Redis ping failed:', error);
});

export { redis };
</file>

<file path="backend/src/controllers/applicationController.ts">
import { Response } from 'express';
import { ApplicationService } from '@/services/applicationService';
import { AuthenticatedRequest } from '@/types';
import { sendSuccess, sendError } from '@/utils/response';
import { logger } from '@/config/logger';

const applicationService = new ApplicationService();

export class ApplicationController {
  async applyToJob(req: AuthenticatedRequest, res: Response) {
    try {
      const { jobId } = req.params;
      const idempotencyKey = req.headers['idempotency-key'] as string;
      
      const result = await applicationService.applyToJob(
        req.user!.id,
        jobId,
        req.body,
        idempotencyKey
      );
      
      sendSuccess(res, result, 'Application submitted successfully', 201);
    } catch (error: any) {
      logger.error('Apply to job error:', error);
      sendError(res, error.message, 400);
    }
  }

  async getMyApplications(req: AuthenticatedRequest, res: Response) {
    try {
      const filters = {
        status: req.query.status as string,
        dateFrom: req.query.dateFrom as string,
        dateTo: req.query.dateTo as string,
        page: parseInt(req.query.page as string) || 1,
        limit: parseInt(req.query.limit as string) || 20,
        sortBy: req.query.sortBy as string,
        sortOrder: req.query.sortOrder as 'asc' | 'desc',
      };
      
      const result = await applicationService.getMyApplications(req.user!.id, filters);
      sendSuccess(res, result);
    } catch (error: any) {
      logger.error('Get my applications error:', error);
      sendError(res, error.message, 400);
    }
  }

  async getApplication(req: AuthenticatedRequest, res: Response) {
    try {
      const { id } = req.params;
      const application = await applicationService.getApplication(req.user!.id, id);
      sendSuccess(res, application);
    } catch (error: any) {
      logger.error('Get application error:', error);
      sendError(res, error.message, 404);
    }
  }

  async updateApplicationStatus(req: AuthenticatedRequest, res: Response) {
    try {
      const { id } = req.params;
      const application = await applicationService.updateApplicationStatus(
        req.user!.id,
        id,
        req.body
      );
      sendSuccess(res, application, 'Application status updated successfully');
    } catch (error: any) {
      logger.error('Update application status error:', error);
      sendError(res, error.message, 400);
    }
  }
}
</file>

<file path="backend/src/controllers/authController.ts">
import { Request, Response } from 'express';
import { AuthService } from '@/services/authService';
import { sendSuccess, sendError } from '@/utils/response';
import { logger } from '@/config/logger';

const authService = new AuthService();

export class AuthController {
  async signup(req: Request, res: Response) {
    try {
      const result = await authService.signup(req.body);
      sendSuccess(res, result, 'User created successfully. Please verify your email.', 201);
    } catch (error: any) {
      logger.error('Signup error:', error);
      sendError(res, error.message, 400);
    }
  }

  async verifyEmail(req: Request, res: Response) {
    try {
      const { userId, otp } = req.body;
      const result = await authService.verifyEmail(userId, otp);
      
      res.cookie('refreshToken', result.refreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
      });

      sendSuccess(res, {
        verified: result.verified,
        accessToken: result.accessToken,
      }, 'Email verified successfully');
    } catch (error: any) {
      logger.error('Email verification error:', error);
      sendError(res, error.message, 400);
    }
  }

  async resendOTP(req: Request, res: Response) {
    try {
      const { userId } = req.body;
      const result = await authService.resendOTP(userId);
      sendSuccess(res, result, 'OTP sent successfully');
    } catch (error: any) {
      logger.error('Resend OTP error:', error);
      sendError(res, error.message, 400);
    }
  }

  async login(req: Request, res: Response) {
    try {
      const { email, password } = req.body;
      const result = await authService.login(email, password);
      
      res.cookie('refreshToken', result.refreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
      });

      sendSuccess(res, {
        accessToken: result.accessToken,
      }, 'Login successful');
    } catch (error: any) {
      logger.error('Login error:', error);
      sendError(res, error.message, 401);
    }
  }

  async refresh(req: Request, res: Response) {
    try {
      const refreshToken = req.cookies.refreshToken;
      
      if (!refreshToken) {
        sendError(res, 'Refresh token not provided', 401);
        return;
      }

      const result = await authService.refreshToken(refreshToken);
      sendSuccess(res, result, 'Token refreshed successfully');
    } catch (error: any) {
      logger.error('Token refresh error:', error);
      res.clearCookie('refreshToken');
      sendError(res, error.message, 401);
    }
  }

  async logout(req: Request, res: Response) {
    try {
      const refreshToken = req.cookies.refreshToken;
      
      if (refreshToken) {
        await authService.logout(refreshToken);
      }

      res.clearCookie('refreshToken');
      res.status(204).send();
    } catch (error: any) {
      logger.error('Logout error:', error);
      res.clearCookie('refreshToken');
      res.status(204).send();
    }
  }
}
</file>

<file path="backend/src/controllers/employerController.ts">
import { Response } from 'express';
import { EmployerService } from '@/services/employerService';
import { AuthenticatedRequest } from '@/types';
import { sendSuccess, sendError } from '@/utils/response';
import { logger } from '@/config/logger';

const employerService = new EmployerService();

export class EmployerController {
  async createEmployer(req: AuthenticatedRequest, res: Response) {
    try {
      const employer = await employerService.createEmployer(req.user!.id, req.body);
      sendSuccess(res, employer, 'Employer created successfully', 201);
    } catch (error: any) {
      logger.error('Create employer error:', error);
      sendError(res, error.message, 400);
    }
  }

  async getEmployer(req: AuthenticatedRequest, res: Response) {
    try {
      const { id } = req.params;
      const employer = await employerService.getEmployer(id);
      sendSuccess(res, employer);
    } catch (error: any) {
      logger.error('Get employer error:', error);
      sendError(res, error.message, 404);
    }
  }

  async updateEmployer(req: AuthenticatedRequest, res: Response) {
    try {
      const { id } = req.params;
      const employer = await employerService.updateEmployer(req.user!.id, id, req.body);
      sendSuccess(res, employer, 'Employer updated successfully');
    } catch (error: any) {
      logger.error('Update employer error:', error);
      sendError(res, error.message, 400);
    }
  }

  async getUserEmployer(req: AuthenticatedRequest, res: Response) {
    try {
      const employer = await employerService.getUserEmployer(req.user!.id);
      sendSuccess(res, employer);
    } catch (error: any) {
      logger.error('Get user employer error:', error);
      sendError(res, error.message, 400);
    }
  }

  async createJob(req: AuthenticatedRequest, res: Response) {
    try {
      const { id } = req.params;
      const job = await employerService.createJob(req.user!.id, id, req.body);
      sendSuccess(res, job, 'Job created successfully', 201);
    } catch (error: any) {
      logger.error('Create job error:', error);
      sendError(res, error.message, 400);
    }
  }

  async getEmployerJobs(req: AuthenticatedRequest, res: Response) {
    try {
      const { id } = req.params;
      const filters = {
        status: req.query.status as string,
        page: parseInt(req.query.page as string) || 1,
        limit: parseInt(req.query.limit as string) || 20,
      };
      
      const result = await employerService.getEmployerJobs(req.user!.id, id, filters);
      sendSuccess(res, result);
    } catch (error: any) {
      logger.error('Get employer jobs error:', error);
      sendError(res, error.message, 400);
    }
  }
}
</file>

<file path="backend/src/controllers/jobController.ts">
import { Request, Response } from 'express';
import { JobService } from '@/services/jobService';
import { AuthenticatedRequest } from '@/types';
import { sendSuccess, sendError } from '@/utils/response';
import { logger } from '@/config/logger';

const jobService = new JobService();

export class JobController {
  async getJob(req: Request, res: Response) {
    try {
      const { id } = req.params;
      const job = await jobService.getPublicJob(id);
      sendSuccess(res, job);
    } catch (error: any) {
      logger.error('Get job error:', error);
      sendError(res, error.message, 404);
    }
  }

  async searchJobs(req: Request, res: Response) {
    try {
      const query = req.query as any;
      const result = await jobService.searchJobs(query);
      sendSuccess(res, result);
    } catch (error: any) {
      logger.error('Search jobs error:', error);
      sendError(res, error.message, 400);
    }
  }

  async updateJob(req: AuthenticatedRequest, res: Response) {
    try {
      const { id } = req.params;
      const job = await jobService.updateJob(req.user!.id, id, req.body);
      sendSuccess(res, job, 'Job updated successfully');
    } catch (error: any) {
      logger.error('Update job error:', error);
      sendError(res, error.message, 400);
    }
  }

  async deleteJob(req: AuthenticatedRequest, res: Response) {
    try {
      const { id } = req.params;
      const result = await jobService.deleteJob(req.user!.id, id);
      sendSuccess(res, result, 'Job deleted successfully');
    } catch (error: any) {
      logger.error('Delete job error:', error);
      sendError(res, error.message, 400);
    }
  }

  async publishJob(req: AuthenticatedRequest, res: Response) {
    try {
      const { id } = req.params;
      const job = await jobService.publishJob(req.user!.id, id);
      sendSuccess(res, job, 'Job published successfully');
    } catch (error: any) {
      logger.error('Publish job error:', error);
      sendError(res, error.message, 400);
    }
  }

  async getJobApplicants(req: AuthenticatedRequest, res: Response) {
    try {
      const { id } = req.params;
      const filters = {
        status: req.query.status as string,
        page: parseInt(req.query.page as string) || 1,
        limit: parseInt(req.query.limit as string) || 20,
      };
      
      const result = await jobService.getJobApplicants(req.user!.id, id, filters);
      sendSuccess(res, result);
    } catch (error: any) {
      logger.error('Get job applicants error:', error);
      sendError(res, error.message, 400);
    }
  }
}
</file>

<file path="backend/src/controllers/notificationController.ts">
import { Response } from 'express';
import { NotificationService } from '@/services/notificationService';
import { AuthenticatedRequest } from '@/types';
import { sendSuccess, sendError } from '@/utils/response';
import { logger } from '@/config/logger';

const notificationService = new NotificationService();

export class NotificationController {
  async getNotifications(req: AuthenticatedRequest, res: Response) {
    try {
      const filters = {
        read: req.query.read === 'true' ? true : req.query.read === 'false' ? false : undefined,
        page: parseInt(req.query.page as string) || 1,
        limit: parseInt(req.query.limit as string) || 20,
      };
      
      const result = await notificationService.getUserNotifications(req.user!.id, filters);
      sendSuccess(res, result);
    } catch (error: any) {
      logger.error('Get notifications error:', error);
      sendError(res, error.message, 400);
    }
  }

  async markAsRead(req: AuthenticatedRequest, res: Response) {
    try {
      const { id } = req.params;
      const result = await notificationService.markAsRead(req.user!.id, id);
      sendSuccess(res, result, 'Notification marked as read');
    } catch (error: any) {
      logger.error('Mark notification as read error:', error);
      sendError(res, error.message, 400);
    }
  }

  async markAllAsRead(req: AuthenticatedRequest, res: Response) {
    try {
      const result = await notificationService.markAllAsRead(req.user!.id);
      sendSuccess(res, result, 'All notifications marked as read');
    } catch (error: any) {
      logger.error('Mark all notifications as read error:', error);
      sendError(res, error.message, 400);
    }
  }
}
</file>

<file path="backend/src/controllers/resumeController.ts">
import { Response } from 'express';
import { ResumeService } from '@/services/resumeService';
import { AuthenticatedRequest } from '@/types';
import { sendSuccess, sendError } from '@/utils/response';
import { logger } from '@/config/logger';

const resumeService = new ResumeService();

export class ResumeController {
  async requestUpload(req: AuthenticatedRequest, res: Response) {
    try {
      const result = await resumeService.requestUpload(req.user!.id, req.body);
      sendSuccess(res, result, 'Upload URL generated successfully');
    } catch (error: any) {
      logger.error('Request upload error:', error);
      sendError(res, error.message, 400);
    }
  }

  async completeUpload(req: AuthenticatedRequest, res: Response) {
    try {
      const result = await resumeService.completeUpload(req.user!.id, req.body);
      sendSuccess(res, result, 'Upload completed successfully', 201);
    } catch (error: any) {
      logger.error('Complete upload error:', error);
      sendError(res, error.message, 400);
    }
  }

  async getResumes(req: AuthenticatedRequest, res: Response) {
    try {
      const resumes = await resumeService.getResumes(req.user!.id);
      sendSuccess(res, resumes);
    } catch (error: any) {
      logger.error('Get resumes error:', error);
      sendError(res, error.message, 400);
    }
  }

  async deleteResume(req: AuthenticatedRequest, res: Response) {
    try {
      const { id } = req.params;
      const result = await resumeService.deleteResume(req.user!.id, id);
      sendSuccess(res, result, 'Resume deleted successfully');
    } catch (error: any) {
      logger.error('Delete resume error:', error);
      sendError(res, error.message, 400);
    }
  }

  async getResume(req: AuthenticatedRequest, res: Response) {
    try {
      const { id } = req.params;
      const resume = await resumeService.getResumeById(req.user!.id, id);
      sendSuccess(res, resume);
    } catch (error: any) {
      logger.error('Get resume error:', error);
      sendError(res, error.message, 400);
    }
  }
}
</file>

<file path="backend/src/controllers/userController.ts">
import { Response } from 'express';
import { UserService } from '@/services/userService';
import { AuthenticatedRequest } from '@/types';
import { sendSuccess, sendError } from '@/utils/response';
import { logger } from '@/config/logger';

const userService = new UserService();

export class UserController {
  async getCurrentUser(req: AuthenticatedRequest, res: Response) {
    try {
      const user = await userService.getCurrentUser(req.user!.id);
      sendSuccess(res, user);
    } catch (error: any) {
      logger.error('Get current user error:', error);
      sendError(res, error.message, 400);
    }
  }

  async updateProfile(req: AuthenticatedRequest, res: Response) {
    try {
      const user = await userService.updateProfile(req.user!.id, req.body);
      sendSuccess(res, user, 'Profile updated successfully');
    } catch (error: any) {
      logger.error('Update profile error:', error);
      sendError(res, error.message, 400);
    }
  }

  async deleteAccount(req: AuthenticatedRequest, res: Response) {
    try {
      await userService.deleteAccount(req.user!.id);
      res.clearCookie('refreshToken');
      sendSuccess(res, { deleted: true }, 'Account deleted successfully');
    } catch (error: any) {
      logger.error('Delete account error:', error);
      sendError(res, error.message, 400);
    }
  }
}
</file>

<file path="backend/src/middleware/errorHandlerMiddleware.ts">
import { Request, Response, NextFunction } from 'express';
import { Prisma } from '@prisma/client';
import { logger } from '@/config/logger';
import { sendError, sendInternalError } from '@/utils/response';

export const errorHandler = (
  error: any,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  logger.error('Error occurred:', {
    error: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent'),
  });

  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case 'P2002':
        sendError(res, 'Resource already exists', 409, 'DUPLICATE_ENTRY');
        return;
      case 'P2025':
        sendError(res, 'Resource not found', 404, 'NOT_FOUND');
        return;
      case 'P2003':
        sendError(res, 'Invalid reference', 400, 'INVALID_REFERENCE');
        return;
      default:
        sendError(res, 'Database error', 400, 'DATABASE_ERROR');
        return;
    }
  }

  if (error instanceof Prisma.PrismaClientValidationError) {
    sendError(res, 'Invalid data provided', 400, 'VALIDATION_ERROR');
    return;
  }

  if (error.name === 'JsonWebTokenError') {
    sendError(res, 'Invalid token', 401, 'INVALID_TOKEN');
    return;
  }

  if (error.name === 'TokenExpiredError') {
    sendError(res, 'Token expired', 401, 'TOKEN_EXPIRED');
    return;
  }

  if (error.name === 'MulterError') {
    if (error.code === 'LIMIT_FILE_SIZE') {
      sendError(res, 'File too large', 413, 'FILE_TOO_LARGE');
      return;
    }
    sendError(res, 'File upload error', 400, 'UPLOAD_ERROR');
    return;
  }

  sendInternalError(res);
};

export const notFoundHandler = (req: Request, res: Response): void => {
  sendError(res, `Route ${req.originalUrl} not found`, 404, 'ROUTE_NOT_FOUND');
};
</file>

<file path="backend/src/middleware/rateLimiterMiddleware.ts">
import rateLimit from 'express-rate-limit';
import { redis } from '@/config/redis';
import { Request } from 'express';
import { logger } from '@/config/logger';

const createRateLimiter = (options: {
  windowMs: number;
  max: number;
  message?: string;
  keyGenerator?: (req: Request) => string;
}) => {
  return rateLimit({
    windowMs: options.windowMs,
    max: options.max,
    message: {
      status: 'error',
      message: options.message || 'Too many requests, please try again later',
      code: 'RATE_LIMIT_EXCEEDED',
    },
    keyGenerator: options.keyGenerator || ((req) => req.ip || 'fallback-ip'),
    store: {
      incr: async (key: string) => {
        try {
          const current = await redis.incr(key);
          if (current === 1) {
            await redis.expire(key, Math.ceil(options.windowMs / 1000));
          }
          return { totalHits: current, resetTime: new Date(Date.now() + options.windowMs) };
        } catch (error) {
          logger.error('Redis incr error:', error);
          // Fallback to memory-based counting
          return { totalHits: 1, resetTime: new Date(Date.now() + options.windowMs) };
        }
      },
      decrement: async (key: string) => {
        try {
          await redis.decr(key);
        } catch (error) {
          logger.error('Redis decr error:', error);
        }
      },
      resetKey: async (key: string) => {
        try {
          await redis.del(key);
        } catch (error) {
          logger.error('Redis del error:', error);
        }
      },
    },
  });
};

export const authLimiter = createRateLimiter({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 attempts per window
  message: 'Too many authentication attempts, please try again later',
});

export const otpLimiter = createRateLimiter({
  windowMs: 60 * 1000, // 1 minute
  max: 3, // 3 OTP requests per minute
  message: 'Too many OTP requests, please try again later',
  keyGenerator: (req) => `otp:${req.ip || 'unknown-ip'}:${req.body.userId || req.body.email || 'unknown-user'}`,
});

export const generalLimiter = createRateLimiter({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS || '900000'), // 15 minutes
  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS || '100'),
  message: 'Too many requests, please try again later',
});

export const uploadLimiter = createRateLimiter({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 10, // 10 uploads per hour
  message: 'Too many upload requests, please try again later',
});
</file>

<file path="backend/src/middleware/validationMiddleware.ts">
import { Request, Response, NextFunction } from 'express';
import { ZodSchema, ZodError } from 'zod';
import { sendValidationError } from '@/utils/response';

export const validateBody = (schema: ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    try {
      req.body = schema.parse(req.body);
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        const errors = error.errors.map(err => ({
          field: err.path.join('.'),
          message: err.message,
        }));
        sendValidationError(res, errors);
      } else {
        sendValidationError(res, 'Invalid request body');
      }
    }
  };
};

export const validateQuery = (schema: ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    try {
      req.query = schema.parse(req.query);
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        const errors = error.errors.map(err => ({
          field: err.path.join('.'),
          message: err.message,
        }));
        sendValidationError(res, errors);
      } else {
        sendValidationError(res, 'Invalid query parameters');
      }
    }
  };
};

export const validateParams = (schema: ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction): void => {
    try {
      req.params = schema.parse(req.params);
      next();
    } catch (error) {
      if (error instanceof ZodError) {
        const errors = error.errors.map(err => ({
          field: err.path.join('.'),
          message: err.message,
        }));
        sendValidationError(res, errors);
      } else {
        sendValidationError(res, 'Invalid path parameters');
      }
    }
  };
};
</file>

<file path="backend/src/routes/authRoutes.ts">
import { Router } from 'express';
import { AuthController } from '@/controllers/authController';
import { validateBody } from '@/middleware/validationMiddleware';
import { authLimiter, otpLimiter } from '@/middleware/rateLimiterMiddleware';
import {
  signupSchema,
  loginSchema,
  verifyEmailSchema,
  resendOTPSchema,
} from '@/utils/validation';

const router: ReturnType<typeof Router> = Router();
const authController = new AuthController();

router.post('/signup', authLimiter, validateBody(signupSchema), authController.signup);
router.post('/verify-email-otp', otpLimiter, validateBody(verifyEmailSchema), authController.verifyEmail);
router.post('/resend-email-otp', otpLimiter, validateBody(resendOTPSchema), authController.resendOTP);
router.post('/login', authLimiter, validateBody(loginSchema), authController.login);
router.post('/refresh', authController.refresh);
router.post('/logout', authController.logout);

export default router;
</file>

<file path="backend/src/routes/index.ts">
import { Router } from 'express';
import authRoutes from './authRoutes';
import userRoutes from './userRoutes';
import resumeRoutes from './resumeRoutes';
import employerRoutes from './employerRoutes';
import jobRoutes from './jobRoutes';
import applicationRoutes from './applicationRoutes';
import notificationRoutes from './notificationRoutes';

const router: ReturnType<typeof Router> = Router();

router.use('/auth', authRoutes);
router.use('/users', userRoutes);
router.use('/resumes', resumeRoutes);
router.use('/employers', employerRoutes);
router.use('/jobs', jobRoutes);
router.use('/applications', applicationRoutes);
router.use('/notifications', notificationRoutes);

// Health check endpoint
router.get('/health', (req, res) => {
  res.json({
    status: 'success',
    message: 'Job Portal API is running',
    timestamp: new Date().toISOString(),
  });
});

export default router;
</file>

<file path="backend/src/routes/notificationRoutes.ts">
import { Router } from 'express';
import { NotificationController } from '@/controllers/notificationController';
import { authenticate, requireEmailVerification } from '@/middleware/authMiddleware';

const router: ReturnType<typeof Router> = Router();
const notificationController = new NotificationController();

router.use(authenticate);
router.use(requireEmailVerification);

router.get('/', notificationController.getNotifications);
router.patch('/:id/read', notificationController.markAsRead);
router.patch('/mark-all-read', notificationController.markAllAsRead);

export default router;
</file>

<file path="backend/src/routes/resumeRoutes.ts">
import { Router } from 'express';
import { ResumeController } from '@/controllers/resumeController';
import { authenticate, requireRole } from '@/middleware/authMiddleware';
import { validateBody } from '@/middleware/validationMiddleware';
import { uploadLimiter } from '@/middleware/rateLimiterMiddleware';
import { requestUploadSchema, completeUploadSchema } from '@/utils/validation';

const router: ReturnType<typeof Router> = Router();
const resumeController = new ResumeController();

router.use(authenticate);
router.use(requireRole(['JOBSEEKER']));

router.post('/request-upload', uploadLimiter, validateBody(requestUploadSchema), resumeController.requestUpload);
router.post('/complete-upload', validateBody(completeUploadSchema), resumeController.completeUpload);
router.get('/', resumeController.getResumes);
router.get('/:id', resumeController.getResume);
router.delete('/:id', resumeController.deleteResume);

export default router;
</file>

<file path="backend/src/routes/userRoutes.ts">
import { Router } from 'express';
import { UserController } from '@/controllers/userController';
import { authenticate } from '@/middleware/authMiddleware';
import { validateBody } from '@/middleware/validationMiddleware';
import { updateProfileSchema } from '@/utils/validation';

const router: ReturnType<typeof Router> = Router();
const userController = new UserController();

router.use(authenticate);

router.get('/me', userController.getCurrentUser);
router.patch('/me', validateBody(updateProfileSchema), userController.updateProfile);
router.delete('/me', userController.deleteAccount);

export default router;
</file>

<file path="backend/src/server.ts">
import dotenv from 'dotenv';
dotenv.config();

import app from './app';
import { logger } from '@/config/logger';
import { prisma } from '@/config/database';
import { redis } from '@/config/redis';

const PORT = process.env.PORT || 4000;

async function startServer() {
  try {
    await prisma.$connect();
    logger.info('Connected to PostgreSQL database');

    await redis.ping();
    logger.info('Connected to Redis');

    app.listen(PORT, () => {
      logger.info(`Server is running on port ${PORT}`);
      logger.info(`Environment: ${process.env.NODE_ENV}`);
    });
  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
}

// Graceful shutdown
process.on('SIGTERM', async () => {
  logger.info('SIGTERM received, shutting down gracefully');
  await prisma.$disconnect();
  await redis.disconnect();
  process.exit(0);
});

process.on('SIGINT', async () => {
  logger.info('SIGINT received, shutting down gracefully');
  await prisma.$disconnect();
  await redis.disconnect();
  process.exit(0);
});

startServer();
</file>

<file path="backend/src/services/applicationService.ts">
import { prisma } from '@/config/database';
import { ApplicationFilters } from '@/types';

export class ApplicationService {
  async applyToJob(userId: string, jobId: string, data: {
    resumeId: string;
    coverLetter?: string;
  }, idempotencyKey?: string) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: { jobSeekerProfile: true },
    });

    if (!user?.jobSeekerProfile) {
      throw new Error('Job seeker profile not found');
    }

    const job = await prisma.job.findFirst({
      where: {
        id: jobId,
        status: 'PUBLISHED',
        OR: [
          { expiresAt: null },
          { expiresAt: { gt: new Date() } },
        ],
      },
    });

    if (!job) {
      throw new Error('Job not found or not available');
    }

    const existingApplication = await prisma.application.findUnique({
      where: {
        jobId_jobSeekerId: {
          jobId,
          jobSeekerId: user.jobSeekerProfile.id,
        },
      },
    });

    if (existingApplication) {
      throw new Error('Already applied to this job');
    }

    const resume = await prisma.resume.findFirst({
      where: {
        id: data.resumeId,
        jobSeekerId: user.jobSeekerProfile.id,
        deleted: false,
      },
    });

    if (!resume) {
      throw new Error('Resume not found');
    }

    const application = await prisma.application.create({
      data: {
        jobId,
        jobSeekerId: user.jobSeekerProfile.id,
        resumeId: data.resumeId,
        coverLetter: data.coverLetter,
        statusHistory: [
          {
            status: 'APPLIED',
            byUserId: userId,
            at: new Date().toISOString(),
            note: 'Application submitted',
          },
        ],
        metadata: {
          idempotencyKey,
          userAgent: 'API',
        },
      },
      include: {
        job: {
          select: {
            id: true,
            title: true,
            employer: {
              select: {
                name: true,
              },
            },
          },
        },
      },
    });

    // TODO: Send notification to employer
    // TODO: Send confirmation email to job seeker

    return { applicationId: application.id };
  }

  async getMyApplications(userId: string, filters: ApplicationFilters) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: { jobSeekerProfile: true },
    });

    if (!user?.jobSeekerProfile) {
      throw new Error('Job seeker profile not found');
    }

    const where: any = { jobSeekerId: user.jobSeekerProfile.id };

    if (filters.status) {
      where.status = filters.status;
    }

    if (filters.dateFrom || filters.dateTo) {
      where.appliedAt = {};
      if (filters.dateFrom) {
        where.appliedAt.gte = new Date(filters.dateFrom);
      }
      if (filters.dateTo) {
        where.appliedAt.lte = new Date(filters.dateTo);
      }
    }

    const orderBy: any = {};
    if (filters.sortBy) {
      orderBy[filters.sortBy] = filters.sortOrder || 'desc';
    } else {
      orderBy.appliedAt = 'desc';
    }

    const [applications, total] = await Promise.all([
      prisma.application.findMany({
        where,
        include: {
          job: {
            select: {
              id: true,
              title: true,
              location: true,
              remote: true,
              jobType: true,
              status: true,
              employer: {
                select: {
                  id: true,
                  name: true,
                  logoKey: true,
                },
              },
            },
          },
          resume: {
            select: {
              id: true,
              fileName: true,
            },
          },
        },
        orderBy,
        skip: ((filters.page || 1) - 1) * (filters.limit || 20),
        take: filters.limit || 20,
      }),
      prisma.application.count({ where }),
    ]);

    return {
      applications,
      pagination: {
        page: filters.page || 1,
        limit: filters.limit || 20,
        total,
        pages: Math.ceil(total / (filters.limit || 20)),
      },
    };
  }

  async getApplication(userId: string, applicationId: string) {
    const application = await prisma.application.findFirst({
      where: {
        id: applicationId,
        OR: [
          { jobSeeker: { userId } },
          { job: { employer: { ownerId: userId } } },
          { job: { employer: { admins: { some: { userId } } } } },
        ],
      },
      include: {
        job: {
          include: {
            employer: {
              select: {
                id: true,
                name: true,
                website: true,
                industry: true,
                location: true,
                logoKey: true,
              },
            },
          },
        },
        jobSeeker: {
          include: {
            user: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                email: true,
                phone: true,
              },
            },
          },
        },
        resume: {
          select: {
            id: true,
            fileName: true,
            fileKey: true,
            parsedJson: true,
          },
        },
      },
    });

    if (!application) {
      throw new Error('Application not found');
    }

    return application;
  }

  async updateApplicationStatus(userId: string, applicationId: string, data: {
    status: string;
    note?: string;
  }) {
    const application = await prisma.application.findFirst({
      where: {
        id: applicationId,
        job: {
          employer: {
            OR: [
              { ownerId: userId },
              { admins: { some: { userId } } },
            ],
          },
        },
      },
      include: {
        job: true,
        jobSeeker: {
          include: { user: true },
        },
      },
    });

    if (!application) {
      throw new Error('Application not found or access denied');
    }

    const validTransitions: Record<string, string[]> = {
      APPLIED: ['VIEWED', 'REJECTED'],
      VIEWED: ['SHORTLISTED', 'REJECTED'],
      SHORTLISTED: ['INTERVIEW_SCHEDULED', 'REJECTED'],
      INTERVIEW_SCHEDULED: ['OFFERED', 'REJECTED'],
      OFFERED: ['HIRED', 'REJECTED'],
      HIRED: [],
      REJECTED: [],
    };

    const allowedStatuses = validTransitions[application.status] || [];
    if (!allowedStatuses.includes(data.status)) {
      throw new Error(`Cannot transition from ${application.status} to ${data.status}`);
    }

    const statusHistory = Array.isArray(application.statusHistory) 
      ? application.statusHistory 
      : [];

    statusHistory.push({
      status: data.status,
      byUserId: userId,
      at: new Date().toISOString(),
      note: data.note,
    });

    const updatedApplication = await prisma.application.update({
      where: { id: applicationId },
      data: {
        status: data.status as any,
        statusHistory,
      },
    });

    // TODO: Send notification to job seeker
    // TODO: Send email notification

    return updatedApplication;
  }
}
</file>

<file path="backend/src/services/authService.ts">
import { prisma } from '@/config/database';
import { 
  hashPassword, 
  comparePassword, 
  generateAccessToken, 
  generateOTP, 
  hashOTP, 
  generateTokenHash,
  generateSecureToken 
} from '@/utils/auth';
import { sendEmail } from '@/config/email';
import { logger } from '@/config/logger';
import { Role } from '@prisma/client';

export class AuthService {
  async signup(data: {
    firstName: string;
    lastName: string;
    email: string;
    password: string;
    role: Role;
  }) {
    const existingUser = await prisma.user.findUnique({
      where: { email: data.email },
    });

    if (existingUser) {
      throw new Error('User already exists');
    }

    const passwordHash = await hashPassword(data.password);
    
    const user = await prisma.user.create({
      data: {
        firstName: data.firstName,
        lastName: data.lastName,
        email: data.email,
        passwordHash,
        role: data.role,
      },
    });

    if (data.role === 'JOBSEEKER') {
      await prisma.jobSeekerProfile.create({
        data: {
          userId: user.id,
        },
      });
    }

    const otp = generateOTP();

    const expiresAt = new Date(Date.now() + parseInt(process.env.OTP_EXPIRES_IN || '600000'));

    await prisma.emailVerification.create({
      data: {
        userId: user.id,
        otp,
        expiresAt,
      },
    });

    await this.sendVerificationEmail(user.email, user.firstName, otp);

    return { userId: user.id, emailVerificationSent: true };
  }

  async verifyEmail(userId: string, otp: string) {
    const verification = await prisma.emailVerification.findFirst({
      where: {
        userId,
        expiresAt: { gt: new Date() },
      },
      include: { user: true },
    });

    if (!verification) {
      throw new Error('Invalid or expired OTP');
    }

    if (verification.otp !== otp) {
      throw new Error('Invalid OTP');
    }

    await prisma.$transaction([
      prisma.user.update({
        where: { id: userId },
        data: { emailVerified: true },
      }),
      prisma.emailVerification.deleteMany({
        where: { userId },
      }),
    ]);

    const tokens = await this.generateTokens(verification.user);
    return { verified: true, ...tokens };
  }

  async resendOTP(userId: string) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
    });

    if (!user) {
      throw new Error('User not found');
    }

    if (user.emailVerified) {
      throw new Error('Email already verified');
    }

    await prisma.emailVerification.deleteMany({
      where: { userId },
    });

    const otp = generateOTP();
    const expiresAt = new Date(Date.now() + parseInt(process.env.OTP_EXPIRES_IN || '600000'));

    await prisma.emailVerification.create({
      data: {
        userId,
        otp,
        expiresAt,
      },
    });

    await this.sendVerificationEmail(user.email, user.firstName, otp);

    return { resent: true };
  }

  async login(email: string, password: string) {
    const user = await prisma.user.findUnique({
      where: { email },
    });

    if (!user) {
      throw new Error('Invalid credentials');
    }

    const isValidPassword = await comparePassword(password, user.passwordHash);
    if (!isValidPassword) {
      throw new Error('Invalid credentials');
    }

    if (!user.emailVerified) {
      throw new Error('Email not verified');
    }

    return this.generateTokens(user);
  }

  async refreshToken(refreshToken: string) {
    const tokenHash = generateTokenHash(refreshToken);
    
    const storedToken = await prisma.refreshToken.findFirst({
      where: {
        tokenHash,
        revoked: false,
        expiresAt: { gt: new Date() },
      },
      include: { user: true },
    });

    if (!storedToken) {
      throw new Error('Invalid refresh token');
    }

    const accessToken = generateAccessToken({
      userId: storedToken.user.id,
      email: storedToken.user.email,
      role: storedToken.user.role,
    });

    return { accessToken };
  }

  async logout(refreshToken: string) {
    const tokenHash = generateTokenHash(refreshToken);
    
    await prisma.refreshToken.updateMany({
      where: { tokenHash },
      data: { revoked: true },
    });

    return { success: true };
  }

  private async generateTokens(user: any) {
    const accessToken = generateAccessToken({
      userId: user.id,
      email: user.email,
      role: user.role,
    });

    const refreshTokenString = generateSecureToken();
    const refreshTokenHash = generateTokenHash(refreshTokenString);
    const expiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 days

    await prisma.refreshToken.create({
      data: {
        tokenHash: refreshTokenHash,
        userId: user.id,
        expiresAt,
      },
    });

    return {
      accessToken,
      refreshToken: refreshTokenString,
    };
  }

  private async sendVerificationEmail(email: string, firstName: string, otp: string) {
    const subject = 'Verify Your Email - Job Portal';
    const html = `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2>Welcome to Job Portal, ${firstName}!</h2>
        <p>Thank you for signing up. Please verify your email address using the OTP below:</p>
        <div style="background-color: #f5f5f5; padding: 20px; text-align: center; margin: 20px 0;">
          <h1 style="color: #333; font-size: 32px; margin: 0;">${otp}</h1>
        </div>
        <p>This OTP will expire in 10 minutes.</p>
        <p>If you didn't create an account, please ignore this email.</p>
        <hr>
        <p style="color: #666; font-size: 12px;">Job Portal Team</p>
      </div>
    `;

    try {
      await sendEmail({ to: email, subject, html });
      logger.info(`Verification email sent to ${email}`);
    } catch (error) {
      logger.error(`Failed to send verification email to ${email}:`, error);
      throw new Error('Failed to send verification email');
    }
  }
}
</file>

<file path="backend/src/services/employerService.ts">
import { prisma } from '@/config/database';
import { generateUniqueSlug } from '@/utils/slugify';

export class EmployerService {
  async createEmployer(userId: string, data: {
    name: string;
    website?: string;
    industry?: string;
    location?: string;
  }) {
    const existingEmployer = await prisma.employer.findUnique({
      where: { ownerId: userId },
    });

    if (existingEmployer) {
      throw new Error('Employer profile already exists');
    }

    const employer = await prisma.employer.create({
      data: {
        ownerId: userId,
        name: data.name,
        website: data.website,
        industry: data.industry,
        location: data.location,
      },
    });

    return employer;
  }

  async getEmployer(employerId: string) {
    const employer = await prisma.employer.findUnique({
      where: { id: employerId },
      include: {
        owner: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
          },
        },
        jobs: {
          where: { status: 'PUBLISHED' },
          orderBy: { postedAt: 'desc' },
          take: 10,
        },
        _count: {
          select: {
            jobs: {
              where: { status: 'PUBLISHED' },
            },
          },
        },
      },
    });

    if (!employer) {
      throw new Error('Employer not found');
    }

    return employer;
  }

  async updateEmployer(userId: string, employerId: string, data: {
    name?: string;
    website?: string;
    industry?: string;
    location?: string;
  }) {
    const employer = await prisma.employer.findFirst({
      where: {
        id: employerId,
        OR: [
          { ownerId: userId },
          { admins: { some: { userId } } },
        ],
      },
    });

    if (!employer) {
      throw new Error('Employer not found or access denied');
    }

    const updatedEmployer = await prisma.employer.update({
      where: { id: employerId },
      data,
    });

    return updatedEmployer;
  }

  async getUserEmployer(userId: string) {
    const employer = await prisma.employer.findUnique({
      where: { ownerId: userId },
      include: {
        jobs: {
          orderBy: { createdAt: 'desc' },
        },
        _count: {
          select: {
            jobs: true,
          },
        },
      },
    });

    return employer;
  }

  async createJob(userId: string, employerId: string, data: {
    title: string;
    description: string;
    responsibilities: string[];
    requirements: string[];
    location?: string;
    remote: boolean;
    jobType: string;
    experienceLevel: string;
    salaryRange?: any;
  }) {
    const employer = await prisma.employer.findFirst({
      where: {
        id: employerId,
        OR: [
          { ownerId: userId },
          { admins: { some: { userId } } },
        ],
      },
    });

    if (!employer) {
      throw new Error('Employer not found or access denied');
    }

    const slug = generateUniqueSlug(data.title);

    const job = await prisma.job.create({
      data: {
        employerId,
        title: data.title,
        slug,
        description: data.description,
        responsibilities: data.responsibilities,
        requirements: data.requirements,
        location: data.location,
        remote: data.remote,
        jobType: data.jobType,
        experienceLevel: data.experienceLevel,
        salaryRange: data.salaryRange,
      },
    });

    return job;
  }

  async getEmployerJobs(userId: string, employerId: string, filters: {
    status?: string;
    page: number;
    limit: number;
  }) {
    const employer = await prisma.employer.findFirst({
      where: {
        id: employerId,
        OR: [
          { ownerId: userId },
          { admins: { some: { userId } } },
        ],
      },
    });

    if (!employer) {
      throw new Error('Employer not found or access denied');
    }

    const where: any = { employerId };
    if (filters.status) {
      where.status = filters.status;
    }

    const [jobs, total] = await Promise.all([
      prisma.job.findMany({
        where,
        include: {
          _count: {
            select: { applications: true },
          },
        },
        orderBy: { createdAt: 'desc' },
        skip: (filters.page - 1) * filters.limit,
        take: filters.limit,
      }),
      prisma.job.count({ where }),
    ]);

    return {
      jobs,
      pagination: {
        page: filters.page,
        limit: filters.limit,
        total,
        pages: Math.ceil(total / filters.limit),
      },
    };
  }
}
</file>

<file path="backend/src/services/jobService.ts">
import { prisma } from '@/config/database';
import { JobSearchQuery } from '@/types';

export class JobService {
  async getPublicJob(jobId: string) {
    const job = await prisma.job.findFirst({
      where: {
        id: jobId,
        status: 'PUBLISHED',
      },
      include: {
        employer: {
          select: {
            id: true,
            name: true,
            website: true,
            industry: true,
            location: true,
            logoKey: true,
          },
        },
        _count: {
          select: { applications: true },
        },
      },
    });

    if (!job) {
      throw new Error('Job not found');
    }

    return job;
  }

  async searchJobs(query: JobSearchQuery) {
    const where: any = {
      status: 'PUBLISHED',
      postedAt: { lte: new Date() },
      OR: [
        { expiresAt: null },
        { expiresAt: { gt: new Date() } },
      ],
    };

    if (query.q) {
      where.OR = [
        { title: { contains: query.q, mode: 'insensitive' } },
        { description: { contains: query.q, mode: 'insensitive' } },
        { requirements: { hasSome: [query.q] } },
        { responsibilities: { hasSome: [query.q] } },
      ];
    }

    if (query.location) {
      where.location = { contains: query.location, mode: 'insensitive' };
    }

    if (query.remote !== undefined) {
      where.remote = query.remote;
    }

    if (query.jobType) {
      where.jobType = query.jobType;
    }

    if (query.experienceLevel) {
      where.experienceLevel = query.experienceLevel;
    }

    if (query.salaryMin || query.salaryMax) {
      where.salaryRange = {};
      if (query.salaryMin) {
        where.salaryRange.path = ['min'];
        where.salaryRange.gte = query.salaryMin;
      }
      if (query.salaryMax) {
        where.salaryRange.path = ['max'];
        where.salaryRange.lte = query.salaryMax;
      }
    }

    const orderBy: any = {};
    if (query.sortBy) {
      orderBy[query.sortBy] = query.sortOrder || 'desc';
    } else {
      orderBy.postedAt = 'desc';
    }

    const [jobs, total] = await Promise.all([
      prisma.job.findMany({
        where,
        include: {
          employer: {
            select: {
              id: true,
              name: true,
              website: true,
              industry: true,
              location: true,
              logoKey: true,
            },
          },
          _count: {
            select: { applications: true },
          },
        },
        orderBy,
        skip: ((query.page || 1) - 1) * (query.limit || 20),
        take: query.limit || 20,
      }),
      prisma.job.count({ where }),
    ]);

    return {
      jobs,
      pagination: {
        page: query.page || 1,
        limit: query.limit || 20,
        total,
        pages: Math.ceil(total / (query.limit || 20)),
      },
    };
  }

  async updateJob(userId: string, jobId: string, data: any) {
    const job = await prisma.job.findFirst({
      where: {
        id: jobId,
        employer: {
          OR: [
            { ownerId: userId },
            { admins: { some: { userId } } },
          ],
        },
      },
    });

    if (!job) {
      throw new Error('Job not found or access denied');
    }

    const updatedJob = await prisma.job.update({
      where: { id: jobId },
      data: {
        ...data,
        updatedAt: new Date(),
      },
    });

    return updatedJob;
  }

  async deleteJob(userId: string, jobId: string) {
    const job = await prisma.job.findFirst({
      where: {
        id: jobId,
        employer: {
          OR: [
            { ownerId: userId },
            { admins: { some: { userId } } },
          ],
        },
      },
    });

    if (!job) {
      throw new Error('Job not found or access denied');
    }

    await prisma.job.update({
      where: { id: jobId },
      data: { status: 'ARCHIVED' },
    });

    return { deleted: true };
  }

  async publishJob(userId: string, jobId: string) {
    const job = await prisma.job.findFirst({
      where: {
        id: jobId,
        employer: {
          OR: [
            { ownerId: userId },
            { admins: { some: { userId } } },
          ],
        },
      },
    });

    if (!job) {
      throw new Error('Job not found or access denied');
    }

    const updatedJob = await prisma.job.update({
      where: { id: jobId },
      data: {
        status: 'PUBLISHED',
        postedAt: new Date(),
      },
    });

    return updatedJob;
  }

  async getJobApplicants(userId: string, jobId: string, filters: {
    status?: string;
    page: number;
    limit: number;
  }) {
    const job = await prisma.job.findFirst({
      where: {
        id: jobId,
        employer: {
          OR: [
            { ownerId: userId },
            { admins: { some: { userId } } },
          ],
        },
      },
    });

    if (!job) {
      throw new Error('Job not found or access denied');
    }

    const where: any = { jobId };
    if (filters.status) {
      where.status = filters.status;
    }

    const [applications, total] = await Promise.all([
      prisma.application.findMany({
        where,
        include: {
          jobSeeker: {
            include: {
              user: {
                select: {
                  id: true,
                  firstName: true,
                  lastName: true,
                  email: true,
                  phone: true,
                },
              },
            },
          },
          resume: {
            select: {
              id: true,
              fileName: true,
              fileKey: true,
              parsedJson: true,
            },
          },
        },
        orderBy: { appliedAt: 'desc' },
        skip: (filters.page - 1) * filters.limit,
        take: filters.limit,
      }),
      prisma.application.count({ where }),
    ]);

    return {
      applications,
      pagination: {
        page: filters.page,
        limit: filters.limit,
        total,
        pages: Math.ceil(total / filters.limit),
      },
    };
  }
}
</file>

<file path="backend/src/services/notificationService.ts">
import { prisma } from '@/config/database';
import { NotificationType, NotificationPayload } from '@/types';
import { sendEmail } from '@/config/email';
import { logger } from '@/config/logger';

export class NotificationService {
  async createNotification(
    userId: string,
    type: NotificationType,
    payload: NotificationPayload
  ) {
    const notification = await prisma.notification.create({
      data: {
        userId,
        type,
        payload,
      },
    });

    // TODO: Send real-time notification via Socket.IO

    return notification;
  }

  async getUserNotifications(userId: string, filters: {
    read?: boolean;
    page: number;
    limit: number;
  }) {
    const where: any = { userId };
    if (filters.read !== undefined) {
      where.read = filters.read;
    }

    const [notifications, total] = await Promise.all([
      prisma.notification.findMany({
        where,
        orderBy: { createdAt: 'desc' },
        skip: (filters.page - 1) * filters.limit,
        take: filters.limit,
      }),
      prisma.notification.count({ where }),
    ]);

    return {
      notifications,
      pagination: {
        page: filters.page,
        limit: filters.limit,
        total,
        pages: Math.ceil(total / filters.limit),
      },
    };
  }

  async markAsRead(userId: string, notificationId: string) {
    const notification = await prisma.notification.findFirst({
      where: {
        id: notificationId,
        userId,
      },
    });

    if (!notification) {
      throw new Error('Notification not found');
    }

    await prisma.notification.update({
      where: { id: notificationId },
      data: { read: true },
    });

    return { success: true };
  }

  async markAllAsRead(userId: string) {
    await prisma.notification.updateMany({
      where: {
        userId,
        read: false,
      },
      data: { read: true },
    });

    return { success: true };
  }

  async sendWelcomeNotification(userId: string, firstName: string) {
    await this.createNotification(userId, 'WELCOME', {
      title: 'Welcome to Job Portal!',
      message: `Hi ${firstName}! Welcome to our job portal. Start exploring opportunities or post your first job.`,
      actionUrl: '/dashboard',
    });
  }

  async sendApplicationReceivedNotification(
    employerUserId: string,
    jobTitle: string,
    applicantName: string,
    applicationId: string
  ) {
    await this.createNotification(employerUserId, 'APPLICATION_RECEIVED', {
      title: 'New Job Application',
      message: `${applicantName} has applied for ${jobTitle}`,
      actionUrl: `/applications/${applicationId}`,
      metadata: { applicationId },
    });
  }

  async sendApplicationStatusChangedNotification(
    jobSeekerUserId: string,
    jobTitle: string,
    status: string,
    applicationId: string
  ) {
    const statusMessages: Record<string, string> = {
      VIEWED: 'Your application has been viewed',
      SHORTLISTED: 'Congratulations! You have been shortlisted',
      INTERVIEW_SCHEDULED: 'Interview has been scheduled',
      OFFERED: 'Congratulations! You have received a job offer',
      HIRED: 'Congratulations! You have been hired',
      REJECTED: 'Your application status has been updated',
    };

    await this.createNotification(jobSeekerUserId, 'APPLICATION_STATUS_CHANGED', {
      title: 'Application Status Update',
      message: `${statusMessages[status]} for ${jobTitle}`,
      actionUrl: `/applications/${applicationId}`,
      metadata: { applicationId, status },
    });
  }

  async sendEmailNotification(
    email: string,
    subject: string,
    template: string,
    data: Record<string, any>
  ) {
    try {
      // Simple template replacement
      let html = template;
      Object.keys(data).forEach(key => {
        html = html.replace(new RegExp(`{{${key}}}`, 'g'), data[key]);
      });

      await sendEmail({
        to: email,
        subject,
        html,
      });

      logger.info(`Email notification sent to ${email}`);
    } catch (error) {
      logger.error(`Failed to send email notification to ${email}:`, error);
      throw error;
    }
  }
}
</file>

<file path="backend/src/services/resumeService.ts">
import { prisma } from '@/config/database';
import { cloudinary, generateUploadSignature } from '@/config/cloudinary';
import { logger } from '@/config/logger';
import crypto from 'crypto';

export class ResumeService {
  async requestUpload(userId: string, data: {
    fileName: string;
    fileType: string;
    fileSize: number;
  }) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: { jobSeekerProfile: true },
    });

    if (!user?.jobSeekerProfile) {
      throw new Error('Job seeker profile not found');
    }

    const allowedTypes = (process.env.ALLOWED_FILE_TYPES || '').split(',');
    if (!allowedTypes.includes(data.fileType)) {
      throw new Error('File type not allowed');
    }

    const maxSize = parseInt(process.env.MAX_FILE_SIZE || '10485760');
    if (data.fileSize > maxSize) {
      throw new Error('File size exceeds limit');
    }

    const fingerprint = crypto
      .createHash('md5')
      .update(`${data.fileName}-${data.fileSize}-${Date.now()}`)
      .digest('hex');

    const resume = await prisma.resume.create({
      data: {
        jobSeekerId: user.jobSeekerProfile.id,
        fileName: data.fileName,
        mimeType: data.fileType,
        size: data.fileSize,
        fingerprint,
        fileKey: '', // Will be updated after upload
      },
    });

    const timestamp = Math.round(Date.now() / 1000);
    const publicId = `job-portal/resumes/${resume.id}`;
    
    const params = {
      timestamp,
      public_id: publicId,
      folder: 'job-portal/resumes',
      resource_type: 'raw',
    };

    const signature = generateUploadSignature(params);

    const uploadUrl = `https://api.cloudinary.com/v1_1/${process.env.CLOUDINARY_CLOUD_NAME}/raw/upload`;

    return {
      uploadUrl,
      resumeId: resume.id,
      uploadParams: {
        ...params,
        signature,
        api_key: process.env.CLOUDINARY_API_KEY,
      },
      expiresAt: new Date(Date.now() + 60 * 60 * 1000), // 1 hour
    };
  }

  async completeUpload(userId: string, data: {
    resumeId: string;
    storageKey: string;
  }) {
    const resume = await prisma.resume.findFirst({
      where: {
        id: data.resumeId,
        jobSeeker: { userId },
      },
    });

    if (!resume) {
      throw new Error('Resume not found');
    }

    await prisma.resume.update({
      where: { id: data.resumeId },
      data: {
        fileKey: data.storageKey,
        parseStatus: 'PENDING',
      },
    });

    // TODO: Enqueue resume parsing job
    logger.info(`Resume upload completed: ${data.resumeId}`);

    return { success: true, resumeId: data.resumeId };
  }

  async getResumes(userId: string) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: { jobSeekerProfile: true },
    });

    if (!user?.jobSeekerProfile) {
      throw new Error('Job seeker profile not found');
    }

    const resumes = await prisma.resume.findMany({
      where: {
        jobSeekerId: user.jobSeekerProfile.id,
        deleted: false,
      },
      orderBy: { createdAt: 'desc' },
    });

    return resumes;
  }

  async deleteResume(userId: string, resumeId: string) {
    const resume = await prisma.resume.findFirst({
      where: {
        id: resumeId,
        jobSeeker: { userId },
      },
    });

    if (!resume) {
      throw new Error('Resume not found');
    }

    await prisma.resume.update({
      where: { id: resumeId },
      data: { deleted: true },
    });

    // TODO: Delete from Cloudinary
    if (resume.fileKey) {
      try {
        await cloudinary.uploader.destroy(resume.fileKey, { resource_type: 'raw' });
        logger.info(`Resume file deleted from Cloudinary: ${resume.fileKey}`);
      } catch (error) {
        logger.error(`Failed to delete resume file from Cloudinary: ${error}`);
      }
    }

    return { deleted: true };
  }

  async getResumeById(userId: string, resumeId: string) {
    const resume = await prisma.resume.findFirst({
      where: {
        id: resumeId,
        jobSeeker: { userId },
        deleted: false,
      },
    });

    if (!resume) {
      throw new Error('Resume not found');
    }

    return resume;
  }
}
</file>

<file path="backend/src/services/userService.ts">
import { prisma } from '@/config/database';
import { AuthenticatedRequest } from '@/types';

export class UserService {
  async getCurrentUser(userId: string) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: {
        jobSeekerProfile: {
          include: {
            resumes: {
              where: { deleted: false },
              orderBy: { createdAt: 'desc' },
            },
          },
        },
        employerProfile: {
          include: {
            jobs: {
              where: { status: { not: 'ARCHIVED' } },
              orderBy: { createdAt: 'desc' },
            },
          },
        },
      },
    });

    if (!user) {
      throw new Error('User not found');
    }

    const { passwordHash, ...userWithoutPassword } = user;
    return userWithoutPassword;
  }

  async updateProfile(userId: string, data: {
    phone?: string;
    desiredTitle?: string;
    about?: string;
    skills?: any;
    privacy?: any;
  }) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: { jobSeekerProfile: true },
    });

    if (!user) {
      throw new Error('User not found');
    }

    const updates: any = {};
    
    if (data.phone !== undefined) {
      updates.phone = data.phone;
    }

    if (user.jobSeekerProfile && (data.desiredTitle !== undefined || data.about !== undefined || data.skills !== undefined || data.privacy !== undefined)) {
      const profileUpdates: any = {};
      
      if (data.desiredTitle !== undefined) profileUpdates.desiredTitle = data.desiredTitle;
      if (data.about !== undefined) profileUpdates.about = data.about;
      if (data.skills !== undefined) profileUpdates.skills = data.skills;
      if (data.privacy !== undefined) profileUpdates.privacy = data.privacy;

      await prisma.jobSeekerProfile.update({
        where: { userId },
        data: profileUpdates,
      });
    }

    if (Object.keys(updates).length > 0) {
      await prisma.user.update({
        where: { id: userId },
        data: updates,
      });
    }

    return this.getCurrentUser(userId);
  }

  async deleteAccount(userId: string) {
    await prisma.$transaction([
      prisma.application.deleteMany({ where: { jobSeeker: { userId } } }),
      prisma.resume.deleteMany({ where: { jobSeeker: { userId } } }),
      prisma.jobSeekerProfile.deleteMany({ where: { userId } }),
      prisma.job.deleteMany({ where: { employer: { ownerId: userId } } }),
      prisma.employer.deleteMany({ where: { ownerId: userId } }),
      prisma.notification.deleteMany({ where: { userId } }),
      prisma.refreshToken.deleteMany({ where: { userId } }),
      prisma.user.delete({ where: { id: userId } }),
    ]);

    return { deleted: true };
  }
}
</file>

<file path="backend/src/types/index.ts">
import { Request } from 'express';
import { User, Role } from '@prisma/client';

export interface AuthenticatedRequest extends Request {
  user?: User;
}

export interface JWTPayload {
  userId: string;
  email: string;
  role: Role;
}

export interface RefreshTokenPayload {
  userId: string;
  tokenId: string;
}

export interface FileUploadResponse {
  uploadUrl: string;
  resumeId: string;
  expiresAt: Date;
}

export interface ApiResponse<T = any> {
  status: 'success' | 'error';
  message?: string;
  data?: T;
  code?: string;
  details?: any;
}

export interface PaginationQuery {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface JobSearchQuery extends PaginationQuery {
  q?: string;
  location?: string;
  remote?: boolean;
  jobType?: string;
  experienceLevel?: string;
  salaryMin?: number;
  salaryMax?: number;
}

export interface ApplicationFilters extends PaginationQuery {
  status?: string;
  dateFrom?: string;
  dateTo?: string;
}

export type NotificationType = 
  | 'APPLICATION_RECEIVED'
  | 'APPLICATION_STATUS_CHANGED'
  | 'JOB_MATCH'
  | 'RESUME_PARSED'
  | 'WELCOME';

export interface NotificationPayload {
  [key: string]: any;
  title: string;
  message: string;
  actionUrl?: string;
  metadata?: Record<string, any>;
}

export interface EmailTemplate {
  subject: string;
  html: string;
  text?: string;
}

export interface JobQueueData {
  type: string;
  payload: any;
  userId?: string;
  priority?: number;
}
</file>

<file path="backend/src/utils/auth.ts">
import jwt, { Secret, SignOptions } from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import crypto from 'crypto';
import { JWTPayload, RefreshTokenPayload } from '@/types';

const JWT_SECRET: Secret = process.env.JWT_SECRET || 'default-secret';
const REFRESH_SECRET: Secret = process.env.REFRESH_TOKEN_SECRET || 'default-refresh';

const ACCESS_EXPIRES_IN: SignOptions['expiresIn'] = (process.env.JWT_EXPIRES_IN as SignOptions['expiresIn']) || '15m';
const REFRESH_EXPIRES_IN: SignOptions['expiresIn'] = (process.env.REFRESH_TOKEN_EXPIRES_IN as SignOptions['expiresIn']) || '7d';

export const hashPassword = async (password: string): Promise<string> => {
  const rounds = parseInt(process.env.BCRYPT_ROUNDS || '12', 10);
  return bcrypt.hash(password, rounds);
};

export const comparePassword = async (password: string, hash: string): Promise<boolean> => {
  return bcrypt.compare(password, hash);
};

// --- JWT Access & Refresh Tokens ---
export const generateAccessToken = (payload: JWTPayload): string =>
  jwt.sign(payload, JWT_SECRET, { expiresIn: ACCESS_EXPIRES_IN });

export const generateRefreshToken = (payload: RefreshTokenPayload): string =>
  jwt.sign(payload, REFRESH_SECRET, { expiresIn: REFRESH_EXPIRES_IN });

export const verifyAccessToken = (token: string): JWTPayload =>
  jwt.verify(token, JWT_SECRET) as JWTPayload;

export const verifyRefreshToken = (token: string): RefreshTokenPayload =>
  jwt.verify(token, REFRESH_SECRET) as RefreshTokenPayload;


export const generateOTP = (): string =>
  Math.floor(100000 + Math.random() * 900000).toString();

export const hashOTP = (otp: string): string =>
  crypto.createHash('sha256').update(otp).digest('hex');


export const generateTokenHash = (token: string): string =>
  crypto.createHash('sha256').update(token).digest('hex');

export const generateSecureToken = (): string =>
  crypto.randomBytes(32).toString('hex');
</file>

<file path="backend/src/utils/response.ts">
import { Response } from 'express';
import { ApiResponse } from '@/types';

export const sendSuccess = <T>(
  res: Response,
  data?: T,
  message?: string,
  statusCode: number = 200
): Response => {
  const response: ApiResponse<T> = {
    status: 'success',
    message,
    data,
  };
  return res.status(statusCode).json(response);
};

export const sendError = (
  res: Response,
  message: string,
  statusCode: number = 400,
  code?: string,
  details?: any
): Response => {
  const response: ApiResponse = {
    status: 'error',
    message,
    code,
    details,
  };
  return res.status(statusCode).json(response);
};

export const sendValidationError = (
  res: Response,
  errors: any,
  message: string = 'Validation failed'
): Response => {
  return sendError(res, message, 422, 'VALIDATION_ERROR', errors);
};

export const sendNotFound = (
  res: Response,
  message: string = 'Resource not found'
): Response => {
  return sendError(res, message, 404, 'NOT_FOUND');
};

export const sendUnauthorized = (
  res: Response,
  message: string = 'Unauthorized'
): Response => {
  return sendError(res, message, 401, 'UNAUTHORIZED');
};

export const sendForbidden = (
  res: Response,
  message: string = 'Forbidden'
): Response => {
  return sendError(res, message, 403, 'FORBIDDEN');
};

export const sendConflict = (
  res: Response,
  message: string = 'Resource already exists'
): Response => {
  return sendError(res, message, 409, 'CONFLICT');
};

export const sendInternalError = (
  res: Response,
  message: string = 'Internal server error'
): Response => {
  return sendError(res, message, 500, 'INTERNAL_ERROR');
};
</file>

<file path="backend/src/utils/slugify.ts">
export const slugify = (text: string): string => {
  return text
    .toString()
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-')
    .replace(/[^\w\-]+/g, '')
    .replace(/\-\-+/g, '-')
    .replace(/^-+/, '')
    .replace(/-+$/, '');
};

export const generateUniqueSlug = (title: string, id?: string): string => {
  const baseSlug = slugify(title);
  const uniqueId = id ? id.slice(-8) : Date.now().toString().slice(-8);
  return `${baseSlug}-${uniqueId}`;
};
</file>

<file path="backend/src/utils/validation.ts">
import { z } from 'zod';

export const signupSchema = z.object({
  firstName: z.string().min(2).max(50),
  lastName: z.string().min(2).max(50),
  email: z.string().email(),
  password: z.string().min(8).regex(
    /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/,
    'Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character'
  ),
  role: z.enum(['JOBSEEKER', 'JOBPROVIDER']),
});

export const loginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
});

export const verifyEmailSchema = z.object({
  userId: z.string().uuid(),
  otp: z.string().length(6),
});

export const resendOTPSchema = z.object({
  userId: z.string().uuid(),
});

export const updateProfileSchema = z.object({
  phone: z.string().optional(),
  desiredTitle: z.string().optional(),
  about: z.string().optional(),
  skills: z.array(z.object({
    id: z.string(),
    name: z.string(),
    confidence: z.number().min(1).max(5),
  })).optional(),
  privacy: z.object({
    hideContact: z.boolean().optional(),
  }).optional(),
});

export const createEmployerSchema = z.object({
  name: z.string().min(2).max(100),
  website: z.string().url().optional(),
  industry: z.string().optional(),
  location: z.string().optional(),
});

export const createJobSchema = z.object({
  title: z.string().min(5).max(100),
  description: z.string().min(50),
  responsibilities: z.array(z.string()).min(1),
  requirements: z.array(z.string()).min(1),
  location: z.string().optional(),
  remote: z.boolean().default(false),
  jobType: z.enum(['FULL_TIME', 'PART_TIME', 'CONTRACT', 'INTERNSHIP']),
  experienceLevel: z.enum(['ENTRY', 'MID', 'SENIOR', 'LEAD', 'EXECUTIVE']),
  salaryRange: z.object({
    min: z.number().min(0),
    max: z.number().min(0),
    currency: z.string().default('USD'),
  }).optional(),
});

export const updateJobSchema = createJobSchema.partial();

export const applyJobSchema = z.object({
  resumeId: z.string().uuid(),
  coverLetter: z.string().optional(),
});

export const updateApplicationStatusSchema = z.object({
  status: z.enum(['VIEWED', 'SHORTLISTED', 'INTERVIEW_SCHEDULED', 'OFFERED', 'HIRED', 'REJECTED']),
  note: z.string().optional(),
});

export const requestUploadSchema = z.object({
  fileName: z.string(),
  fileType: z.string(),
  fileSize: z.number().max(parseInt(process.env.MAX_FILE_SIZE || '10485760')),
});

export const completeUploadSchema = z.object({
  resumeId: z.string().uuid(),
  storageKey: z.string(),
});

export const paginationSchema = z.object({
  page: z.coerce.number().min(1).default(1),
  limit: z.coerce.number().min(1).max(100).default(20),
  sortBy: z.string().optional(),
  sortOrder: z.enum(['asc', 'desc']).default('desc'),
});

export const jobSearchSchema = paginationSchema.extend({
  q: z.string().optional(),
  location: z.string().optional(),
  remote: z.coerce.boolean().optional(),
  jobType: z.string().optional(),
  experienceLevel: z.string().optional(),
  salaryMin: z.coerce.number().optional(),
  salaryMax: z.coerce.number().optional(),
});
</file>

<file path="backend/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "baseUrl": "./src",
    "paths": {
      "@/*": ["./*"],
      "@/types/*": ["./types/*"],
      "@/utils/*": ["./utils/*"],
      "@/middleware/*": ["./middleware/*"],
      "@/services/*": ["./services/*"],
      "@/controllers/*": ["./controllers/*"],
      "@/routes/*": ["./routes/*"]
    }
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "**/*.test.ts"
  ]
}
</file>

<file path="backend/package.json">
{
  "name": "rnrs-backend",
  "version": "1.0.0",
  "description": "Job Portal Backend API with Express, TypeScript, and Prisma",
  "main": "dist/server.js",
  "scripts": {
    "dev": "nodemon src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:deploy": "prisma migrate deploy",
    "db:seed": "tsx src/scripts/seed.ts",
    "test": "jest",
    "test:watch": "jest --watch",
    "lint": "eslint src/**/*.ts",
    "lint:fix": "eslint src/**/*.ts --fix"
  },
  "dependencies": {
    "@prisma/client": "^5.6.0",
    "bcryptjs": "^2.4.3",
    "bullmq": "^4.15.0",
    "cloudinary": "^1.41.0",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "crypto": "^1.0.1",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-rate-limit": "^7.1.5",
    "helmet": "^7.1.0",
    "ioredis": "^5.3.2",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.1",
    "nodemailer": "^6.9.7",
    "socket.io": "^4.7.4",
    "uuid": "^9.0.1",
    "winston": "^3.11.0",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cookie-parser": "^1.4.6",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jest": "^29.5.8",
    "@types/jsonwebtoken": "^9.0.5",
    "@types/multer": "^1.4.11",
    "@types/node": "^20.9.0",
    "@types/nodemailer": "^6.4.14",
    "@types/uuid": "^9.0.7",
    "@typescript-eslint/eslint-plugin": "^6.12.0",
    "@typescript-eslint/parser": "^6.12.0",
    "eslint": "^8.54.0",
    "jest": "^29.7.0",
    "nodemon": "^3.0.1",
    "prisma": "^5.6.0",
    "ts-jest": "^29.1.1",
    "ts-node": "^10.9.1",
    "tsconfig-paths": "^4.2.0",
    "tsx": "^4.6.0",
    "typescript": "^5.2.2"
  },
  "keywords": [
    "job-portal",
    "express",
    "typescript",
    "prisma",
    "postgresql"
  ],
  "author": "Alex",
  "license": "MIT"
}
</file>

<file path="backend/src/app.ts">
import express, {Express} from 'express';
import cors from 'cors';
import helmet from 'helmet';
import cookieParser from 'cookie-parser';
import { generalLimiter } from '@/middleware/rateLimiterMiddleware';
import { errorHandler, notFoundHandler } from '@/middleware/errorHandlerMiddleware';
import { logger } from '@/config/logger';
import routes from '@/routes';

const app:Express = express();

// Security middleware
app.use(helmet());
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true,
}));

// Rate limiting
app.use(generalLimiter);

// Body parsing middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(cookieParser());

// Request logging
app.use((req, res, next) => {
  logger.info(`${req.method} ${req.path}`, {
    ip: req.ip,
    userAgent: req.get('User-Agent'),
  });
  next();
});

// API routes
app.use('/api/v1', routes);

// Error handling
app.use(notFoundHandler);
app.use(errorHandler);

export default app;
</file>

<file path="backend/src/config/logger.ts">
import winston from 'winston';

const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'production' ? 'info' : 'debug',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'rnrs-backend-api' },
  transports: [
    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),
    new winston.transports.File({ filename: 'logs/combined.log' }),
  ],
});

if (process.env.NODE_ENV !== 'production') {
  logger.add(new winston.transports.Console({
    format: winston.format.combine(
      winston.format.colorize(),
      winston.format.simple()
    )
  }));
}

export { logger };
</file>

<file path="backend/src/middleware/authMiddleware.ts">
import { Response, NextFunction } from 'express';
import { verifyAccessToken } from '@/utils/auth';
import { prisma } from '@/config/database';
import { sendUnauthorized, sendForbidden } from '@/utils/response';
import { AuthenticatedRequest } from '@/types';
import { Role } from '@prisma/client';

export const authenticate = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      sendUnauthorized(res, 'Access token required');
      return;
    }

    const token = authHeader.substring(7);
    const payload = verifyAccessToken(token);

    const user = await prisma.user.findUnique({
      where: { id: payload.userId },
      include: {
        jobSeekerProfile: true,
        employerProfile: true,
      },
    });

    if (!user) {
      sendUnauthorized(res, 'User not found');
      return;
    }

    if (!user.emailVerified) {
      sendUnauthorized(res, 'Email not verified');
      return;
    }

    req.user = user;
    next();
  } catch (error) {
    sendUnauthorized(res, 'Invalid or expired token');
  }
};

export const requireRole = (roles: Role[]) => {
  return (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {
    if (!req.user) {
      sendUnauthorized(res);
      return;
    }

    if (!roles.includes(req.user.role)) {
      sendForbidden(res, 'Insufficient permissions');
      return;
    }

    next();
  };
};

export const requireEmailVerification = (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): void => {
  if (!req.user?.emailVerified) {
    sendUnauthorized(res, 'Email verification required');
    return;
  }
  next();
};
</file>

<file path="backend/src/routes/applicationRoutes.ts">
import { Router } from 'express';
import { ApplicationController } from '@/controllers/applicationController';
import { authenticate, requireRole } from '@/middleware/authMiddleware';
import { validateBody } from '@/middleware/validationMiddleware';
import { applyJobSchema, updateApplicationStatusSchema } from '@/utils/validation';

const router: ReturnType<typeof Router> = Router();
const applicationController = new ApplicationController();

router.use(authenticate);

// Job seeker routes
router.post('/jobs/:jobId/apply', requireRole(['JOBSEEKER']), validateBody(applyJobSchema), applicationController.applyToJob);
router.get('/', requireRole(['JOBSEEKER']), applicationController.getMyApplications);

// Shared routes (job seeker can view their applications, employers can view applications to their jobs)
router.get('/:id', applicationController.getApplication);

// Employer routes
router.patch('/:id/status', requireRole(['JOBPROVIDER']), validateBody(updateApplicationStatusSchema), applicationController.updateApplicationStatus);

export default router;
</file>

<file path="backend/src/routes/employerRoutes.ts">
import { Router } from 'express';
import { EmployerController } from '@/controllers/employerController';
import { authenticate, requireRole } from '@/middleware/authMiddleware';
import { validateBody } from '@/middleware/validationMiddleware';
import { createEmployerSchema, createJobSchema } from '@/utils/validation';

const router: ReturnType<typeof Router> = Router();
const employerController = new EmployerController();

router.use(authenticate);

router.post('/', requireRole(['JOBPROVIDER']), validateBody(createEmployerSchema), employerController.createEmployer);
router.get('/me', requireRole(['JOBPROVIDER']), employerController.getUserEmployer);
router.get('/:id', employerController.getEmployer);
router.patch('/:id', requireRole(['JOBPROVIDER']), employerController.updateEmployer);
router.post('/:id/jobs', requireRole(['JOBPROVIDER']), validateBody(createJobSchema), employerController.createJob);
router.get('/:id/jobs', requireRole(['JOBPROVIDER']), employerController.getEmployerJobs);

export default router;
</file>

<file path="backend/src/routes/jobRoutes.ts">
import { Router } from 'express';
import { JobController } from '@/controllers/jobController';
import { authenticate, requireRole } from '@/middleware/authMiddleware';
import { validateBody, validateQuery } from '@/middleware/validationMiddleware';
import { updateJobSchema, jobSearchSchema } from '@/utils/validation';

const router: ReturnType<typeof Router> = Router();
const jobController = new JobController();

router.get('/search', validateQuery(jobSearchSchema), jobController.searchJobs);
router.get('/:id', jobController.getJob);

router.use(authenticate);
router.use(requireRole(['JOBPROVIDER']));

router.patch('/:id', validateBody(updateJobSchema), jobController.updateJob);
router.delete('/:id', jobController.deleteJob);
router.post('/:id/publish', jobController.publishJob);
router.get('/:id/applicants', jobController.getJobApplicants);

export default router;
</file>

<file path="backend/src/scripts/seed.ts">
import { PrismaClient, JobStatus } from '@prisma/client';
import { hashPassword } from '@/utils/auth';

const prisma = new PrismaClient();

async function seed() {
  console.log('🌱 Seeding database...');

  try {
    // Create admin user
    const adminPassword = await hashPassword('Admin123!');
    const admin = await prisma.user.upsert({
      where: { email: 'admin@rnrs.com' },
      update: {},
      create: {
        firstName: 'Admin',
        lastName: 'User',
        email: 'admin@rnrs.com',
        passwordHash: adminPassword,
        role: 'ADMIN',
        emailVerified: true,
      },
    });

    console.log('✅ Admin user created');

    // Create job seeker
    const jobSeekerPassword = await hashPassword('JobSeeker123!');
    const jobSeeker = await prisma.user.upsert({
      where: { email: 'jobseeker@example.com' },
      update: {},
      create: {
        firstName: 'John',
        lastName: 'Doe',
        email: 'jobseeker@example.com',
        passwordHash: jobSeekerPassword,
        role: 'JOBSEEKER',
        emailVerified: true,
        phone: '+250791234567',
        jobSeekerProfile: {
          create: {
            desiredTitle: 'Software Engineer',
            about: 'Passionate software engineer with 3+ years of experience in full-stack development.',
            skills: [
              { id: '1', name: 'JavaScript', confidence: 5 },
              { id: '2', name: 'React', confidence: 4 },
              { id: '3', name: 'Node.js', confidence: 4 },
              { id: '4', name: 'TypeScript', confidence: 4 },
            ],
            privacy: { hideContact: false },
          },
        },
      },
    });

    console.log('✅ Job seeker created');

    // Create job provider
    const jobProviderPassword = await hashPassword('JobProvider123!');
    const jobProvider = await prisma.user.upsert({
      where: { email: 'jobprovider@example.com' },
      update: {},
      create: {
        firstName: 'Jane',
        lastName: 'Smith',
        email: 'jobprovider@example.com',
        passwordHash: jobProviderPassword,
        role: 'JOBPROVIDER',
        emailVerified: true,
        phone: '+250791234568',
        employerProfile: {
          create: {
            name: 'TechCorp Inc.',
            website: 'https://techcorp.com',
            industry: 'Technology',
            location: 'Kigali, Rwanda',
          },
        },
      },
    });

    console.log('✅ Job provider created');

    // Create sample jobs
    const employer = await prisma.employer.findUnique({
      where: { ownerId: jobProvider.id },
    });

    if (employer) {
      const jobs = [
        {
          title: 'Senior Full Stack Developer',
          slug: 'senior-full-stack-developer-' + Date.now(),
          description: 'We are looking for a senior full stack developer to join our growing team.',
          responsibilities: [
            'Develop and maintain web applications',
            'Collaborate with cross-functional teams',
            'Write clean, maintainable code',
            'Mentor junior developers',
          ],
          requirements: [
            '5+ years of experience in full stack development',
            'Proficiency in JavaScript, React, and Node.js',
            'Experience with databases (PostgreSQL, MongoDB)',
            'Strong problem-solving skills',
          ],
          location: 'San Francisco, CA',
          remote: true,
          jobType: 'FULL_TIME',
          experienceLevel: 'SENIOR',
          salaryRange: {
            min: 120000,
            max: 180000,
            currency: 'USD',
          },
          status: JobStatus.PUBLISHED,
          postedAt: new Date(),
          expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
        },
        {
          title: 'Frontend Developer',
          slug: 'frontend-developer-' + Date.now(),
          description: 'Join our team as a frontend developer and help build amazing user experiences.',
          responsibilities: [
            'Build responsive web applications',
            'Implement UI/UX designs',
            'Optimize application performance',
            'Write unit and integration tests',
          ],
          requirements: [
            '3+ years of experience in frontend development',
            'Proficiency in React, TypeScript, and CSS',
            'Experience with modern build tools',
            'Knowledge of web accessibility standards',
          ],
          location: 'Remote',
          remote: true,
          jobType: 'FULL_TIME',
          experienceLevel: 'MID',
          salaryRange: {
            min: 80000,
            max: 120000,
            currency: 'USD',
          },
          status: JobStatus.PUBLISHED,
          postedAt: new Date(),
          expiresAt: new Date(Date.now() + 45 * 24 * 60 * 60 * 1000), // 45 days
        },
      ];

      for (const jobData of jobs) {
        await prisma.job.create({
          data: {
            ...jobData,
            employerId: employer.id,
          },
        });
      }

      console.log('✅ Sample jobs created');
    }

    console.log('🎉 Database seeded successfully!');
    console.log('\n📋 Test Accounts:');
    console.log('Admin: admin@rnrs.com / Admin123!');
    console.log('Job Seeker: jobseeker@example.com / JobSeeker123!');
    console.log('Job Provider: jobprovider@example.com / JobProvider123!');

  } catch (error) {
    console.error('❌ Error seeding database:', error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

seed().catch((error) => {
  console.error(error);
  process.exit(1);
});
</file>

</files>
